// 
// Decompiled by Procyon v0.5.30
// 

package com.google.android.gms.common.api;

import android.app.PendingIntent;
import java.util.concurrent.TimeUnit;
import android.os.DeadObjectException;
import android.util.Log;
import com.google.android.gms.internal.fq;
import java.util.Iterator;
import com.google.android.gms.common.GooglePlayServicesClient$OnConnectionFailedListener;
import java.util.HashSet;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.concurrent.locks.ReentrantLock;
import com.google.android.gms.internal.fc;
import android.content.Context;
import com.google.android.gms.internal.fg$b;
import java.util.Set;
import java.util.Map;
import android.os.Bundle;
import android.os.Handler;
import com.google.android.gms.common.ConnectionResult;
import java.util.Queue;
import com.google.android.gms.internal.fg;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import android.os.Looper;

final class b implements GoogleApiClient
{
    private final b$a AL;
    private final Looper AS;
    private final Lock Ba;
    private final Condition Bb;
    private final fg Bc;
    final Queue Bd;
    private ConnectionResult Be;
    private int Bf;
    private int Bg;
    private int Bh;
    private boolean Bi;
    private int Bj;
    private long Bk;
    final Handler Bl;
    private final Bundle Bm;
    private final Map Bn;
    private boolean Bo;
    final Set Bp;
    final GoogleApiClient$ConnectionCallbacks Bq;
    private final fg$b Br;
    
    public b(final Context context, final Looper as, final fc fc, final Map map, final Set set, final Set set2) {
        this.Ba = new ReentrantLock();
        this.Bb = this.Ba.newCondition();
        this.Bd = new LinkedList();
        this.Bg = 4;
        this.Bh = 0;
        this.Bi = false;
        this.Bk = 5000L;
        this.Bm = new Bundle();
        this.Bn = new HashMap();
        this.Bp = new HashSet();
        this.AL = new b$a() {
            @Override
            public void b(final b$c b$c) {
                b.this.Ba.lock();
                try {
                    b.this.Bp.remove(b$c);
                }
                finally {
                    b.this.Ba.unlock();
                }
            }
        };
        this.Bq = new GoogleApiClient$ConnectionCallbacks() {
            @Override
            public void onConnected(final Bundle bundle) {
                b.this.Ba.lock();
                try {
                    if (b.this.Bg == 1) {
                        if (bundle != null) {
                            b.this.Bm.putAll(bundle);
                        }
                        b.this.ei();
                    }
                }
                finally {
                    b.this.Ba.unlock();
                }
            }
            
            @Override
            public void onConnectionSuspended(final int n) {
                while (true) {
                    b.this.Ba.lock();
                    Label_0082: {
                        try {
                            b.this.E(n);
                            switch (n) {
                                case 2: {
                                    b.this.connect();
                                    break;
                                }
                                case 1: {
                                    break Label_0082;
                                }
                            }
                            return;
                        }
                        finally {
                            b.this.Ba.unlock();
                        }
                    }
                    if (b.this.ek()) {
                        break;
                    }
                    b.this.Bh = 2;
                    b.this.Bl.sendMessageDelayed(b.this.Bl.obtainMessage(1), b.this.Bk);
                    return;
                }
                b.this.Ba.unlock();
            }
        };
        this.Br = new fg$b() {
            @Override
            public Bundle dG() {
                return null;
            }
            
            @Override
            public boolean em() {
                return b.this.Bo;
            }
            
            @Override
            public boolean isConnected() {
                return b.this.isConnected();
            }
        };
        this.Bc = new fg(context, as, this.Br);
        this.AS = as;
        this.Bl = new b$b(this, as);
        final Iterator<GoogleApiClient$ConnectionCallbacks> iterator = set.iterator();
        while (iterator.hasNext()) {
            this.Bc.registerConnectionCallbacks(iterator.next());
        }
        final Iterator<GoogleApiClient$OnConnectionFailedListener> iterator2 = set2.iterator();
        while (iterator2.hasNext()) {
            this.Bc.registerConnectionFailedListener(iterator2.next());
        }
        for (final Api api : map.keySet()) {
            final Api$b dy = api.dY();
            this.Bn.put(api.ea(), a(dy, map.get(api), context, as, fc, this.Bq, new GoogleApiClient$OnConnectionFailedListener() {
                @Override
                public void onConnectionFailed(final ConnectionResult connectionResult) {
                    b.this.Ba.lock();
                    try {
                        if (b.this.Be == null || dy.getPriority() < b.this.Bf) {
                            b.this.Be = connectionResult;
                            b.this.Bf = dy.getPriority();
                        }
                        b.this.ei();
                    }
                    finally {
                        b.this.Ba.unlock();
                    }
                }
            }));
        }
    }
    
    private void E(final int n) {
        this.Ba.lock();
        Label_0327: {
            Label_0190: {
                Label_0111: {
                    try {
                        if (this.Bg == 3) {
                            break Label_0327;
                        }
                        if (n != -1) {
                            break Label_0190;
                        }
                        if (this.isConnecting()) {
                            final Iterator iterator = this.Bd.iterator();
                            while (iterator.hasNext()) {
                                final b$c b$c = iterator.next();
                                if (b$c.ef() != 1) {
                                    b$c.cancel();
                                    iterator.remove();
                                }
                            }
                            break Label_0111;
                        }
                    }
                    finally {
                        this.Ba.unlock();
                    }
                    this.Bd.clear();
                }
                final Iterator<b$c> iterator2 = this.Bp.iterator();
                while (iterator2.hasNext()) {
                    iterator2.next().cancel();
                }
                this.Bp.clear();
                if (this.Be == null && !this.Bd.isEmpty()) {
                    this.Bi = true;
                    this.Ba.unlock();
                    return;
                }
            }
            final boolean connecting = this.isConnecting();
            final boolean connected = this.isConnected();
            this.Bg = 3;
            if (connecting) {
                if (n == -1) {
                    this.Be = null;
                }
                this.Bb.signalAll();
            }
            this.Bo = false;
            for (final Api$a api$a : this.Bn.values()) {
                if (api$a.isConnected()) {
                    api$a.disconnect();
                }
            }
            this.Bo = true;
            this.Bg = 4;
            if (connected) {
                if (n != -1) {
                    this.Bc.O(n);
                }
                this.Bo = false;
            }
        }
        this.Ba.unlock();
    }
    
    private static Api$a a(final Api$b api$b, final Object o, final Context context, final Looper looper, final fc fc, final GoogleApiClient$ConnectionCallbacks googleApiClient$ConnectionCallbacks, final GoogleApiClient$OnConnectionFailedListener googleApiClient$OnConnectionFailedListener) {
        return api$b.a(context, looper, fc, o, googleApiClient$ConnectionCallbacks, googleApiClient$OnConnectionFailedListener);
    }
    
    private void a(final b$c b$c) {
        while (true) {
            boolean b = true;
            this.Ba.lock();
            while (true) {
                try {
                    if (!this.isConnected()) {
                        if (!this.ek()) {
                            final boolean b2 = false;
                            fq.a(b2, (Object)"GoogleApiClient is not connected yet.");
                            if (b$c.ea() == null) {
                                b = false;
                            }
                            fq.b(b, "This task can not be executed or enqueued (it's probably a Batch or malformed)");
                            this.Bp.add(b$c);
                            b$c.a(this.AL);
                            if (this.ek()) {
                                b$c.k(new Status(8));
                                return;
                            }
                            b$c.b(this.a(b$c.ea()));
                            return;
                        }
                    }
                }
                finally {
                    this.Ba.unlock();
                }
                final boolean b2 = b;
                continue;
            }
        }
    }
    
    private void ei() {
        while (true) {
            this.Ba.lock();
            Label_0128: {
                try {
                    --this.Bj;
                    if (this.Bj == 0) {
                        if (this.Be == null) {
                            break Label_0128;
                        }
                        this.Bi = false;
                        this.E(3);
                        if (this.ek()) {
                            --this.Bh;
                        }
                        if (this.ek()) {
                            this.Bl.sendMessageDelayed(this.Bl.obtainMessage(1), this.Bk);
                        }
                        else {
                            this.Bc.a(this.Be);
                        }
                        this.Bo = false;
                    }
                    return;
                }
                finally {
                    this.Ba.unlock();
                }
            }
            this.Bg = 2;
            this.el();
            this.Bb.signalAll();
            this.ej();
            if (this.Bi) {
                this.Bi = false;
                this.E(-1);
                return;
            }
            Bundle bm;
            if (this.Bm.isEmpty()) {
                bm = null;
            }
            else {
                bm = this.Bm;
            }
            this.Bc.b(bm);
        }
    }
    
    private void ej() {
        while (true) {
            Label_0094: {
                if (!this.isConnected() && !this.ek()) {
                    break Label_0094;
                }
                final boolean b = true;
                fq.a(b, (Object)"GoogleApiClient is not connected yet.");
                this.Ba.lock();
                Label_0099: {
                    try {
                        while (!this.Bd.isEmpty()) {
                            try {
                                this.a(this.Bd.remove());
                            }
                            catch (DeadObjectException ex) {
                                Log.w("GoogleApiClientImpl", "Service died while flushing queue", (Throwable)ex);
                            }
                        }
                        break Label_0099;
                    }
                    finally {
                        this.Ba.unlock();
                    }
                    break Label_0094;
                }
                this.Ba.unlock();
                return;
            }
            final boolean b = false;
            continue;
        }
    }
    
    private boolean ek() {
        this.Ba.lock();
        try {
            return this.Bh != 0;
        }
        finally {
            this.Ba.unlock();
        }
    }
    
    private void el() {
        this.Ba.lock();
        try {
            this.Bh = 0;
            this.Bl.removeMessages(1);
        }
        finally {
            this.Ba.unlock();
        }
    }
    
    @Override
    public final Api$a a(final Api$c api$c) {
        final Api$a api$a = this.Bn.get(api$c);
        fq.b(api$a, "Appropriate Api was not requested.");
        return api$a;
    }
    
    @Override
    public final a$b a(final a$b a$b) {
        this.Ba.lock();
        try {
            if (this.isConnected()) {
                this.b(a$b);
            }
            else {
                this.Bd.add(a$b);
            }
            return a$b;
        }
        finally {
            this.Ba.unlock();
        }
    }
    
    @Override
    public final a$b b(final a$b a$b) {
        Label_0034: {
            if (!this.isConnected() && !this.ek()) {
                break Label_0034;
            }
            boolean b = true;
            while (true) {
                fq.a(b, (Object)"GoogleApiClient is not connected yet.");
                this.ej();
                try {
                    this.a((b$c)a$b);
                    return a$b;
                    b = false;
                }
                catch (DeadObjectException ex) {
                    this.E(1);
                    return a$b;
                }
            }
        }
    }
    
    @Override
    public final ConnectionResult blockingConnect(final long n, final TimeUnit timeUnit) {
        Label_0095: {
            if (Looper.myLooper() == Looper.getMainLooper()) {
                break Label_0095;
            }
            boolean b = true;
        Label_0012:
            while (true) {
                fq.a(b, (Object)"blockingConnect must not be called on the UI thread");
                this.Ba.lock();
                try {
                    this.connect();
                    long n2 = timeUnit.toNanos(n);
                    while (this.isConnecting()) {
                        try {
                            n2 = this.Bb.awaitNanos(n2);
                            if (n2 <= 0L) {
                                return new ConnectionResult(14, null);
                            }
                            continue;
                            b = false;
                            continue Label_0012;
                        }
                        catch (InterruptedException ex) {
                            Thread.currentThread().interrupt();
                            return new ConnectionResult(15, null);
                        }
                        break;
                    }
                    if (this.isConnected()) {
                        return ConnectionResult.Ag;
                    }
                    if (this.Be != null) {
                        return this.Be;
                    }
                    return new ConnectionResult(13, null);
                }
                finally {
                    this.Ba.unlock();
                }
            }
        }
    }
    
    @Override
    public final void connect() {
        this.Ba.lock();
        try {
            this.Bi = false;
            if (this.isConnected() || this.isConnecting()) {
                return;
            }
            this.Bo = true;
            this.Be = null;
            this.Bg = 1;
            this.Bm.clear();
            this.Bj = this.Bn.size();
            final Iterator<Api$a> iterator = this.Bn.values().iterator();
            while (iterator.hasNext()) {
                iterator.next().connect();
            }
        }
        finally {
            this.Ba.unlock();
        }
        this.Ba.unlock();
    }
    
    @Override
    public final void disconnect() {
        this.el();
        this.E(-1);
    }
    
    @Override
    public final Looper getLooper() {
        return this.AS;
    }
    
    @Override
    public final boolean isConnected() {
        this.Ba.lock();
        try {
            return this.Bg == 2;
        }
        finally {
            this.Ba.unlock();
        }
    }
    
    @Override
    public final boolean isConnecting() {
        boolean b = true;
        this.Ba.lock();
        try {
            if (this.Bg != (b ? 1 : 0)) {
                b = false;
            }
            return b;
        }
        finally {
            this.Ba.unlock();
        }
    }
    
    @Override
    public final boolean isConnectionCallbacksRegistered(final GoogleApiClient$ConnectionCallbacks googleApiClient$ConnectionCallbacks) {
        return this.Bc.isConnectionCallbacksRegistered(googleApiClient$ConnectionCallbacks);
    }
    
    @Override
    public final boolean isConnectionFailedListenerRegistered(final GoogleApiClient$OnConnectionFailedListener googleApiClient$OnConnectionFailedListener) {
        return this.Bc.isConnectionFailedListenerRegistered(googleApiClient$OnConnectionFailedListener);
    }
    
    @Override
    public final void reconnect() {
        this.disconnect();
        this.connect();
    }
    
    @Override
    public final void registerConnectionCallbacks(final GoogleApiClient$ConnectionCallbacks googleApiClient$ConnectionCallbacks) {
        this.Bc.registerConnectionCallbacks(googleApiClient$ConnectionCallbacks);
    }
    
    @Override
    public final void registerConnectionFailedListener(final GoogleApiClient$OnConnectionFailedListener googleApiClient$OnConnectionFailedListener) {
        this.Bc.registerConnectionFailedListener(googleApiClient$OnConnectionFailedListener);
    }
    
    @Override
    public final void unregisterConnectionCallbacks(final GoogleApiClient$ConnectionCallbacks googleApiClient$ConnectionCallbacks) {
        this.Bc.unregisterConnectionCallbacks(googleApiClient$ConnectionCallbacks);
    }
    
    @Override
    public final void unregisterConnectionFailedListener(final GoogleApiClient$OnConnectionFailedListener googleApiClient$OnConnectionFailedListener) {
        this.Bc.unregisterConnectionFailedListener(googleApiClient$OnConnectionFailedListener);
    }
}
