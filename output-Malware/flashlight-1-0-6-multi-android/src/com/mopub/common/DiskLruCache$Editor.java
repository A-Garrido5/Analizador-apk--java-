// 
// Decompiled by Procyon v0.5.30
// 

package com.mopub.common;

import java.util.ArrayList;
import java.util.Map;
import java.io.EOFException;
import java.util.Iterator;
import java.io.BufferedWriter;
import java.io.Reader;
import java.io.InputStreamReader;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.LinkedHashMap;
import java.io.Writer;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.Callable;
import java.util.regex.Pattern;
import java.util.Arrays;
import java.io.Closeable;
import java.io.OutputStreamWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.io.FileNotFoundException;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.IOException;

public final class DiskLruCache$Editor
{
    private boolean committed;
    private final DiskLruCache$Entry entry;
    private boolean hasErrors;
    final /* synthetic */ DiskLruCache this$0;
    private final boolean[] written;
    
    private DiskLruCache$Editor(final DiskLruCache this$0, final DiskLruCache$Entry entry) {
        this.this$0 = this$0;
        this.entry = entry;
        boolean[] written;
        if (entry.readable) {
            written = null;
        }
        else {
            written = new boolean[this$0.valueCount];
        }
        this.written = written;
    }
    
    public final void abort() {
        this.this$0.completeEdit(this, false);
    }
    
    public final void abortUnlessCommitted() {
        if (this.committed) {
            return;
        }
        try {
            this.abort();
        }
        catch (IOException ex) {}
    }
    
    public final void commit() {
        if (this.hasErrors) {
            this.this$0.completeEdit(this, false);
            this.this$0.remove(this.entry.key);
        }
        else {
            this.this$0.completeEdit(this, true);
        }
        this.committed = true;
    }
    
    public final String getString(final int n) {
        final InputStream inputStream = this.newInputStream(n);
        if (inputStream != null) {
            return inputStreamToString(inputStream);
        }
        return null;
    }
    
    public final InputStream newInputStream(final int n) {
        synchronized (this.this$0) {
            if (this.entry.currentEditor != this) {
                throw new IllegalStateException();
            }
        }
        if (!this.entry.readable) {
            // monitorexit(diskLruCache)
            return null;
        }
        try {
            // monitorexit(diskLruCache)
            return new FileInputStream(this.entry.getCleanFile(n));
        }
        catch (FileNotFoundException ex) {
            // monitorexit(diskLruCache)
            return null;
        }
    }
    
    public final OutputStream newOutputStream(final int n) {
        synchronized (this.this$0) {
            if (this.entry.currentEditor != this) {
                throw new IllegalStateException();
            }
        }
        if (!this.entry.readable) {
            this.written[n] = true;
        }
        final File dirtyFile = this.entry.getDirtyFile(n);
        try {
            final FileOutputStream fileOutputStream = new FileOutputStream(dirtyFile);
            // monitorexit(diskLruCache)
            return new DiskLruCache$Editor$FaultHidingOutputStream(this, fileOutputStream, null);
        }
        catch (FileNotFoundException ex) {
            this.this$0.directory.mkdirs();
            try {
                final FileOutputStream fileOutputStream = new FileOutputStream(dirtyFile);
            }
            catch (FileNotFoundException ex2) {
                // monitorexit(diskLruCache)
                return DiskLruCache.NULL_OUTPUT_STREAM;
            }
        }
    }
    
    public final void set(final int n, final String s) {
        OutputStreamWriter outputStreamWriter;
        try {
            final OutputStreamWriter outputStreamWriter2;
            outputStreamWriter = (outputStreamWriter2 = new OutputStreamWriter(this.newOutputStream(n), DiskLruCacheUtil.UTF_8));
            final String s2 = s;
            outputStreamWriter2.write(s2);
            final OutputStreamWriter outputStreamWriter3 = outputStreamWriter;
            DiskLruCacheUtil.closeQuietly(outputStreamWriter3);
            return;
        }
        finally {
            final Object o2;
            final Object o = o2;
            outputStreamWriter = null;
        }
        while (true) {
            try {
                final OutputStreamWriter outputStreamWriter2 = outputStreamWriter;
                final String s2 = s;
                outputStreamWriter2.write(s2);
                final OutputStreamWriter outputStreamWriter3 = outputStreamWriter;
                DiskLruCacheUtil.closeQuietly(outputStreamWriter3);
                return;
                DiskLruCacheUtil.closeQuietly(outputStreamWriter);
                throw;
            }
            finally {
                continue;
            }
            break;
        }
    }
}
