// 
// Decompiled by Procyon v0.5.30
// 

package com.inmobi.commons.cache;

import com.inmobi.commons.uid.UID;
import com.inmobi.commons.uid.UIDUtil;
import org.json.JSONException;
import org.json.JSONObject;
import android.content.IntentFilter;
import android.content.Intent;
import android.content.BroadcastReceiver;
import android.content.Context;
import java.util.Iterator;
import com.inmobi.commons.internal.CommonsException;
import com.inmobi.commons.internal.Log;
import com.inmobi.commons.internal.InternalSDKUtil;
import java.util.HashMap;
import java.util.Map;

public final class CacheController
{
    private static Map a;
    private static ProductCacheConfig b;
    private static boolean c;
    private static Map d;
    private static Map e;
    
    static {
        CacheController.a = new HashMap();
        CacheController.b = null;
        CacheController.c = true;
        CacheController.d = new HashMap();
        CacheController.e = new HashMap();
    }
    
    static void a() {
        final Map d = CacheController.d;
    Label_0140:
        while (true) {
            String s;
            Map e;
            synchronized (d) {
                final Iterator<String> iterator = CacheController.d.keySet().iterator();
                while (iterator.hasNext()) {
                    s = iterator.next();
                    try {
                        if (!InternalSDKUtil.checkNetworkAvailibility(InternalSDKUtil.getContext())) {
                            continue;
                        }
                        e = CacheController.e;
                        // monitorenter(e)
                        final Map map = CacheController.e;
                        final String s2 = s;
                        final Map map2 = map.get(s2);
                        final Map map3 = map2;
                        final Map map4 = e;
                        // monitorexit(map4)
                        final String s3 = s;
                        final Context context = null;
                        final Map map5 = map3;
                        final Map map6 = CacheController.d;
                        final String s4 = s;
                        final CacheController$Validator cacheController$Validator = map6.get(s4);
                        final CacheController$Validator cacheController$Validator2 = cacheController$Validator;
                        getConfig(s3, context, map5, cacheController$Validator2);
                    }
                    catch (CommonsException ex) {
                        Log.internal("[InMobi]-4.4.3", "Unable to reinitialize product " + s);
                    }
                }
                break Label_0140;
            }
            try {
                final Map map = CacheController.e;
                final String s2 = s;
                final Map map2 = map.get(s2);
                final Map map3 = map2;
                final Map map4 = e;
                // monitorexit(map4)
                final String s3 = s;
                final Context context = null;
                final Map map5 = map3;
                final Map map6 = CacheController.d;
                final String s4 = s;
                final CacheController$Validator cacheController$Validator = map6.get(s4);
                final CacheController$Validator cacheController$Validator2 = cacheController$Validator;
                getConfig(s3, context, map5, cacheController$Validator2);
                continue;
            }
            finally {
            }
            // monitorexit(e)
            break;
        }
        // monitorexit(d)
        if (CacheController.b != null) {
            CacheController.b.getData(null);
        }
    }
    
    private static boolean b(final Map map) {
        try {
            final Map populateToNewMap = InternalSDKUtil.populateToNewMap(map.get("AND"), map.get("common"), true);
            c(populateToNewMap);
            final Iterator<String> iterator = populateToNewMap.keySet().iterator();
            while (iterator.hasNext()) {
                final Map value = populateToNewMap.get(iterator.next());
                if (value instanceof Map) {
                    c(value);
                }
            }
        }
        catch (Exception ex) {
            return false;
        }
        return true;
    }
    
    private static void c(final Map map) {
        InternalSDKUtil.getIntFromMap(map, "expiry", 1, 2147483647L);
        InternalSDKUtil.getIntFromMap(map, "maxRetry", 0, 2147483647L);
        InternalSDKUtil.getIntFromMap(map, "retryInterval", 1, 2147483647L);
        InternalSDKUtil.getStringFromMap(map, "url");
        InternalSDKUtil.getStringFromMap(map, "protocol");
    }
    
    private static void d() {
        InternalSDKUtil.getContext().registerReceiver((BroadcastReceiver)new BroadcastReceiver() {
            public final void onReceive(final Context context, final Intent intent) {
                CacheController.a();
            }
        }, new IntentFilter("android.net.conn.CONNECTIVITY_CHANGE"));
    }
    
    private static void e() {
        Log.internal("[InMobi]-4.4.3", "Bootstrapping cache.");
        LocalCache.initRoot();
        final Iterator keys = LocalCache.getRoot().keys();
        while (keys.hasNext()) {
            final String s = keys.next();
            try {
                final Object value = LocalCache.getRoot().get(s);
                if (!(value instanceof JSONObject)) {
                    continue;
                }
                final ProductCacheConfig productCacheConfig = new ProductCacheConfig((JSONObject)value, new CacheController$Committer() {
                    @Override
                    public final void onCommit() {
                        try {
                            final ProductCacheConfig productCacheConfig = CacheController.a.get(s);
                            if (productCacheConfig == null) {
                                return;
                            }
                            LocalCache.addToCache(s, productCacheConfig.toJSON());
                        }
                        catch (JSONException ex) {
                            Log.internal("[InMobi]-4.4.3", "Unable to add json to persistent memory", (Throwable)ex);
                        }
                    }
                });
                final ProductCacheConfig productCacheConfig2 = CacheController.a.get(s);
                if (productCacheConfig2 != null) {
                    productCacheConfig.setValidator(productCacheConfig2.getValidator());
                    productCacheConfig.setMap(productCacheConfig2.getMap());
                }
                CacheController.a.put(s, productCacheConfig);
            }
            catch (JSONException ex) {
                Log.internal("[InMobi]-4.4.3", "Unable to dump config from persistent memory to products in memory", (Throwable)ex);
            }
        }
        if (CacheController.b == null) {
            (CacheController.b = new ProductCacheConfig(LocalCache.getRoot(), new CacheController$Committer() {
                @Override
                public final void onCommit() {
                    f();
                }
            })).getData(UIDUtil.getMap(InternalSDKUtil.getContext(), null), new CacheController$Validator() {
                @Override
                public final boolean validate(final Map map) {
                    return b(map);
                }
            });
        }
        else {
            CacheController.b.loadFromJSON(LocalCache.getRoot());
        }
        InternalSDKUtil.initialize(InternalSDKUtil.getContext());
    }
    
    private static void f() {
        try {
            final JSONObject jsonObject = new JSONObject(CacheController.b.getRawData());
            final JSONObject populateToNewJSON = InternalSDKUtil.populateToNewJSON(jsonObject.getJSONObject("AND"), jsonObject.getJSONObject("common"), true);
            while (true) {
                Label_0187: {
                    String s;
                    while (true) {
                        try {
                            populateToNewJSON.put("timestamp", (int)(System.currentTimeMillis() / 1000L));
                            final Iterator keys = populateToNewJSON.keys();
                            while (keys.hasNext()) {
                                s = keys.next();
                                try {
                                    final JSONObject jsonObject2 = LocalCache.getRoot();
                                    final String s2 = s;
                                    final Object o = jsonObject2.get(s2);
                                    final Object o3;
                                    final Object o2 = o3 = o;
                                    final boolean b = o3 instanceof JSONObject;
                                    if (!b) {
                                        continue;
                                    }
                                    final Map map = CacheController.a;
                                    final String s3 = s;
                                    final ProductCacheConfig productCacheConfig = map.get(s3);
                                    final ProductCacheConfig productCacheConfig2 = productCacheConfig;
                                    final ProductCacheConfig productCacheConfig4;
                                    final ProductCacheConfig productCacheConfig3 = productCacheConfig4 = productCacheConfig2;
                                    if (productCacheConfig4 == null) {
                                        continue;
                                    }
                                    final JSONObject jsonObject3 = (JSONObject)o2;
                                    final JSONObject jsonObject4 = jsonObject3;
                                    final String s4 = "timestamp";
                                    final int n = 0;
                                    jsonObject4.put(s4, n);
                                    final JSONObject jsonObject5 = (JSONObject)o2;
                                    final JSONObject jsonObject6 = jsonObject5;
                                    final String s5 = "data";
                                    final ProductCacheConfig productCacheConfig5 = productCacheConfig3;
                                    final String s6 = productCacheConfig5.getRawData();
                                    jsonObject6.put(s5, (Object)s6);
                                }
                                catch (Exception ex) {
                                    Log.internal("[InMobi]-4.4.3", "Error while merging data -> " + ex.getMessage());
                                }
                            }
                            break Label_0187;
                        }
                        catch (JSONException ex2) {
                            Log.internal("[InMobi]-4.4.3", "Unable to add timestamp to JSON");
                            continue;
                        }
                        break;
                    }
                    try {
                        final JSONObject jsonObject2 = LocalCache.getRoot();
                        final String s2 = s;
                        final Object o = jsonObject2.get(s2);
                        final Object o3;
                        final Object o2 = o3 = o;
                        final boolean b = o3 instanceof JSONObject;
                        if (!b) {
                            continue;
                        }
                        final Map map = CacheController.a;
                        final String s3 = s;
                        final ProductCacheConfig productCacheConfig = map.get(s3);
                        final ProductCacheConfig productCacheConfig2 = productCacheConfig;
                        final ProductCacheConfig productCacheConfig4;
                        final ProductCacheConfig productCacheConfig3 = productCacheConfig4 = productCacheConfig2;
                        if (productCacheConfig4 != null) {
                            final JSONObject jsonObject3 = (JSONObject)o2;
                            final JSONObject jsonObject4 = jsonObject3;
                            final String s4 = "timestamp";
                            final int n = 0;
                            jsonObject4.put(s4, n);
                            final JSONObject jsonObject5 = (JSONObject)o2;
                            final JSONObject jsonObject6 = jsonObject5;
                            final String s5 = "data";
                            final ProductCacheConfig productCacheConfig5 = productCacheConfig3;
                            final String s6 = productCacheConfig5.getRawData();
                            jsonObject6.put(s5, (Object)s6);
                            continue;
                        }
                        continue;
                        LocalCache.saveRoot(populateToNewJSON);
                        e();
                        a();
                    }
                    catch (JSONException ex3) {}
                }
                break;
            }
        }
        catch (JSONException ex4) {}
    }
    
    public static ProductConfig getConfig(final String p0, final Context p1, final Map p2, final CacheController$Validator p3) {
        // 
        // This method could not be decompiled.
        // 
        // Original Bytecode:
        // 
        //     0: aload_3        
        //     1: ifnull          26
        //     4: getstatic       com/inmobi/commons/cache/CacheController.d:Ljava/util/Map;
        //     7: astore          10
        //     9: aload           10
        //    11: monitorenter   
        //    12: getstatic       com/inmobi/commons/cache/CacheController.d:Ljava/util/Map;
        //    15: aload_0        
        //    16: aload_3        
        //    17: invokeinterface java/util/Map.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
        //    22: pop            
        //    23: aload           10
        //    25: monitorexit    
        //    26: aload_2        
        //    27: ifnull          52
        //    30: getstatic       com/inmobi/commons/cache/CacheController.e:Ljava/util/Map;
        //    33: astore          7
        //    35: aload           7
        //    37: monitorenter   
        //    38: getstatic       com/inmobi/commons/cache/CacheController.e:Ljava/util/Map;
        //    41: aload_0        
        //    42: aload_2        
        //    43: invokeinterface java/util/Map.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
        //    48: pop            
        //    49: aload           7
        //    51: monitorexit    
        //    52: getstatic       com/inmobi/commons/cache/CacheController.c:Z
        //    55: ifeq            107
        //    58: invokestatic    com/inmobi/commons/internal/InternalSDKUtil.getContext:()Landroid/content/Context;
        //    61: ifnonnull       97
        //    64: aload_1        
        //    65: ifnonnull       93
        //    68: new             Lcom/inmobi/commons/internal/CommonsException;
        //    71: dup            
        //    72: iconst_1       
        //    73: invokespecial   com/inmobi/commons/internal/CommonsException.<init>:(I)V
        //    76: athrow         
        //    77: astore          11
        //    79: aload           10
        //    81: monitorexit    
        //    82: aload           11
        //    84: athrow         
        //    85: astore          8
        //    87: aload           7
        //    89: monitorexit    
        //    90: aload           8
        //    92: athrow         
        //    93: aload_1        
        //    94: invokestatic    com/inmobi/commons/internal/InternalSDKUtil.setContext:(Landroid/content/Context;)V
        //    97: iconst_0       
        //    98: putstatic       com/inmobi/commons/cache/CacheController.c:Z
        //   101: invokestatic    com/inmobi/commons/cache/CacheController.e:()V
        //   104: invokestatic    com/inmobi/commons/cache/CacheController.d:()V
        //   107: getstatic       com/inmobi/commons/cache/CacheController.b:Lcom/inmobi/commons/cache/ProductCacheConfig;
        //   110: aconst_null    
        //   111: invokevirtual   com/inmobi/commons/cache/ProductCacheConfig.getData:(Lcom/inmobi/commons/cache/CacheController$Validator;)Ljava/lang/String;
        //   114: pop            
        //   115: getstatic       com/inmobi/commons/cache/CacheController.a:Ljava/util/Map;
        //   118: aload_0        
        //   119: invokeinterface java/util/Map.get:(Ljava/lang/Object;)Ljava/lang/Object;
        //   124: checkcast       Lcom/inmobi/commons/cache/ProductCacheConfig;
        //   127: astore          5
        //   129: aload           5
        //   131: ifnonnull       143
        //   134: new             Lcom/inmobi/commons/internal/CommonsException;
        //   137: dup            
        //   138: iconst_2       
        //   139: invokespecial   com/inmobi/commons/internal/CommonsException.<init>:(I)V
        //   142: athrow         
        //   143: aload           5
        //   145: aload_2        
        //   146: aload_3        
        //   147: invokevirtual   com/inmobi/commons/cache/ProductCacheConfig.getData:(Ljava/util/Map;Lcom/inmobi/commons/cache/CacheController$Validator;)Ljava/lang/String;
        //   150: pop            
        //   151: aload           5
        //   153: areturn        
        //    Exceptions:
        //  Try           Handler
        //  Start  End    Start  End    Type
        //  -----  -----  -----  -----  ----
        //  12     26     77     85     Any
        //  38     52     85     93     Any
        // 
        // The error that occurred was:
        // 
        // java.lang.IllegalStateException: Expression is linked from several locations: Label_0052:
        //     at com.strobel.decompiler.ast.Error.expressionLinkedFromMultipleLocations(Error.java:27)
        //     at com.strobel.decompiler.ast.AstOptimizer.mergeDisparateObjectInitializations(AstOptimizer.java:2592)
        //     at com.strobel.decompiler.ast.AstOptimizer.optimize(AstOptimizer.java:235)
        //     at com.strobel.decompiler.ast.AstOptimizer.optimize(AstOptimizer.java:42)
        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:214)
        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:99)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethodBody(AstBuilder.java:757)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethod(AstBuilder.java:655)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addTypeMembers(AstBuilder.java:532)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeCore(AstBuilder.java:499)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeNoCache(AstBuilder.java:141)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createType(AstBuilder.java:130)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addType(AstBuilder.java:105)
        //     at com.strobel.decompiler.languages.java.JavaLanguage.buildAst(JavaLanguage.java:71)
        //     at com.strobel.decompiler.languages.java.JavaLanguage.decompileType(JavaLanguage.java:59)
        //     at com.strobel.decompiler.DecompilerDriver.decompileType(DecompilerDriver.java:317)
        //     at com.strobel.decompiler.DecompilerDriver.decompileJar(DecompilerDriver.java:238)
        //     at com.strobel.decompiler.DecompilerDriver.main(DecompilerDriver.java:123)
        // 
        throw new IllegalStateException("An error occurred while decompiling this method.");
    }
}
