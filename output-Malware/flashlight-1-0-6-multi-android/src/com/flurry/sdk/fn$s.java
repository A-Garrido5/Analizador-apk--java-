// 
// Decompiled by Procyon v0.5.30
// 

package com.flurry.sdk;

import java.util.LinkedHashMap;
import java.util.Set;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.List;

class fn$s extends fn$n
{
    private List i;
    private Map j;
    private final boolean k;
    
    public fn$s(final fn$m fn$m, final String s, final boolean k) {
        super(fn$v.a, fn$m, s);
        this.k = k;
    }
    
    @Override
    void a(final fn$o fn$o, final hf hf) {
        if (this.c(fn$o, hf)) {
            return;
        }
        final String a = fn$o.a;
        hf.d();
        String s;
        if (this.k) {
            s = "error";
        }
        else {
            s = "record";
        }
        hf.a("type", s);
        this.d(fn$o, hf);
        fn$o.a = this.f.b;
        if (this.e() != null) {
            hf.a("doc", this.e());
        }
        hf.a("fields");
        this.b(fn$o, hf);
        this.c.a(hf);
        this.a(hf);
        hf.e();
        fn$o.a = a;
    }
    
    @Override
    public fn$f b(final String s) {
        if (this.j == null) {
            throw new fk("Schema fields not set yet");
        }
        return this.j.get(s);
    }
    
    @Override
    public List b() {
        if (this.i == null) {
            throw new fk("Schema fields not set yet");
        }
        return this.i;
    }
    
    @Override
    void b(final fn$o fn$o, final hf hf) {
        hf.b();
        for (final fn$f fn$f : this.i) {
            hf.d();
            hf.a("name", fn$f.a());
            hf.a("type");
            fn$f.c().a(fn$o, hf);
            if (fn$f.d() != null) {
                hf.a("doc", fn$f.d());
            }
            if (fn$f.e() != null) {
                hf.a("default");
                hf.a(fn$f.e());
            }
            if (fn$f.f() != fn$f$a.a) {
                hf.a("order", fn$f.f().d);
            }
            if (fn$f.g != null && fn$f.g.size() != 0) {
                hf.a("aliases");
                hf.b();
                final Iterator iterator2 = fn$f.g.iterator();
                while (iterator2.hasNext()) {
                    hf.b(iterator2.next());
                }
                hf.c();
            }
            fn$f.h.a(hf);
            hf.e();
        }
        hf.c();
    }
    
    @Override
    public void c(final List list) {
        if (this.i != null) {
            throw new fk("Fields are already set");
        }
        this.j = new HashMap();
        final fn$j fn$j = new fn$j();
        final Iterator<fn$f> iterator = list.iterator();
        int n = 0;
        while (iterator.hasNext()) {
            final fn$f fn$f = iterator.next();
            if (fn$f.b != -1) {
                throw new fk("Field already used: " + fn$f);
            }
            final int n2 = n + 1;
            fn$f.b = n;
            this.j.put(fn$f.a(), fn$f);
            fn$j.add(fn$f);
            n = n2;
        }
        this.i = fn$j.a();
        this.d = Integer.MIN_VALUE;
    }
    
    @Override
    public boolean equals(final Object o) {
        if (o == this) {
            return true;
        }
        if (!(o instanceof fn$s)) {
            return false;
        }
        final fn$s fn$s = (fn$s)o;
        if (!this.c(fn$s)) {
            return false;
        }
        if (!this.a(fn$s)) {
            return false;
        }
        if (!this.c.equals(fn$s.c)) {
            return false;
        }
        final Set<fn$t> set = fn.o().get();
        final fn$t fn$t = new fn$t(this, o, null);
        if (set.contains(fn$t)) {
            return true;
        }
        final boolean empty = set.isEmpty();
        try {
            set.add(fn$t);
            return this.i.equals(((fn$s)o).i);
        }
        finally {
            if (empty) {
                set.clear();
            }
        }
    }
    
    @Override
    public boolean h() {
        return this.k;
    }
    
    @Override
    int m() {
        final Map<fn$s, fn$s> map = fn.p().get();
        if (map.containsKey(this)) {
            return 0;
        }
        final boolean empty = map.isEmpty();
        try {
            map.put(this, this);
            return super.m() + this.i.hashCode();
        }
        finally {
            if (empty) {
                map.clear();
            }
        }
    }
}
