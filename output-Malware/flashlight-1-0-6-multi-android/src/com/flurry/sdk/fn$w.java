// 
// Decompiled by Procyon v0.5.30
// 

package com.flurry.sdk;

import java.util.Iterator;
import java.util.HashMap;
import java.util.Map;
import java.util.List;

class fn$w extends fn
{
    private final List f;
    private final Map g;
    
    public fn$w(final fn$j fn$j) {
        super(fn$v.e);
        this.g = new HashMap();
        this.f = fn$j.a();
        final Iterator<fn> iterator = (Iterator<fn>)fn$j.iterator();
        int n = 0;
        while (iterator.hasNext()) {
            final fn fn = iterator.next();
            if (fn.a() == fn$v.e) {
                throw new fk("Nested union: " + this);
            }
            final String g = fn.g();
            if (g == null) {
                throw new fk("Nameless in union:" + this);
            }
            final Map g2 = this.g;
            final int n2 = n + 1;
            if (g2.put(g, n) != null) {
                throw new fk("Duplicate in union:" + g);
            }
            n = n2;
        }
    }
    
    @Override
    void a(final fn$o fn$o, final hf hf) {
        hf.b();
        final Iterator<fn> iterator = this.f.iterator();
        while (iterator.hasNext()) {
            iterator.next().a(fn$o, hf);
        }
        hf.c();
    }
    
    @Override
    public void a(final String s, final String s2) {
        throw new fk("Can't set properties on a union: " + this);
    }
    
    @Override
    public Integer e(final String s) {
        return this.g.get(s);
    }
    
    @Override
    public boolean equals(final Object o) {
        if (o != this) {
            if (!(o instanceof fn$w)) {
                return false;
            }
            final fn$w fn$w = (fn$w)o;
            if (!this.c(fn$w) || !this.f.equals(fn$w.f) || !this.c.equals(fn$w.c)) {
                return false;
            }
        }
        return true;
    }
    
    @Override
    public List k() {
        return this.f;
    }
    
    @Override
    int m() {
        final int m = super.m();
        final Iterator<fn> iterator = (Iterator<fn>)this.f.iterator();
        int n = m;
        while (iterator.hasNext()) {
            n += iterator.next().m();
        }
        return n;
    }
}
