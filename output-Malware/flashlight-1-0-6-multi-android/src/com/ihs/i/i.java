// 
// Decompiled by Procyon v0.5.30
// 

package com.ihs.i;

import java.net.Socket;
import java.util.Iterator;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.io.IOException;
import javax.net.ssl.SSLSession;
import java.util.ArrayList;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import java.nio.channels.SocketChannel;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.nio.ByteBuffer;
import java.nio.channels.ByteChannel;

public class i implements al, ByteChannel
{
    protected static ByteBuffer a;
    static final /* synthetic */ boolean j;
    protected ExecutorService b;
    protected List c;
    protected ByteBuffer d;
    protected ByteBuffer e;
    protected ByteBuffer f;
    protected SocketChannel g;
    protected SSLEngineResult h;
    protected SSLEngine i;
    private SSLEngineResult.Status k;
    
    static {
        j = !i.class.desiredAssertionStatus();
        i.a = ByteBuffer.allocate(0);
    }
    
    public i(final SocketChannel g, final SSLEngine i, final ExecutorService b) {
        this.k = SSLEngineResult.Status.BUFFER_UNDERFLOW;
        if (g == null || i == null || b == null) {
            throw new IllegalArgumentException("parameter must not be null");
        }
        this.g = g;
        this.i = i;
        this.b = b;
        this.c = new ArrayList(3);
        this.a(i.getSession());
        this.g.write(this.a(com.ihs.i.i.a));
        this.c();
    }
    
    private static int a(final ByteBuffer byteBuffer, final ByteBuffer byteBuffer2) {
        final int remaining = byteBuffer.remaining();
        final int remaining2 = byteBuffer2.remaining();
        if (remaining > remaining2) {
            final int min = Math.min(remaining, remaining2);
            for (int i = 0; i < min; ++i) {
                byteBuffer2.put(byteBuffer.get());
            }
            return min;
        }
        byteBuffer2.put(byteBuffer);
        return remaining;
    }
    
    private ByteBuffer a(final ByteBuffer byteBuffer) {
        synchronized (this) {
            this.e.compact();
            this.h = this.i.wrap(byteBuffer, this.e);
            this.e.flip();
            return this.e;
        }
    }
    
    private void a(final SSLSession sslSession) {
        final int applicationBufferSize = sslSession.getApplicationBufferSize();
        final int packetBufferSize = sslSession.getPacketBufferSize();
        if (this.d == null) {
            this.d = ByteBuffer.allocate(applicationBufferSize);
            this.e = ByteBuffer.allocate(packetBufferSize);
            this.f = ByteBuffer.allocate(packetBufferSize);
        }
        else {
            if (this.d.capacity() != applicationBufferSize) {
                this.d = ByteBuffer.allocate(applicationBufferSize);
            }
            if (this.e.capacity() != packetBufferSize) {
                this.e = ByteBuffer.allocate(packetBufferSize);
            }
            if (this.f.capacity() != packetBufferSize) {
                this.f = ByteBuffer.allocate(packetBufferSize);
            }
        }
        this.d.rewind();
        this.d.flip();
        this.f.rewind();
        this.f.flip();
        this.e.rewind();
        this.e.flip();
    }
    
    private void c() {
        while (true) {
            Label_0209: {
                Future future;
                while (true) {
                    final Iterator iterator;
                    Label_0126: {
                        synchronized (this) {
                            if (this.h.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                                return;
                            }
                            if (!this.c.isEmpty()) {
                                iterator = this.c.iterator();
                                if (iterator.hasNext()) {
                                    break Label_0126;
                                }
                            }
                            if (this.h.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                                break Label_0209;
                            }
                            if (this.g.isBlocking() && this.k != SSLEngineResult.Status.BUFFER_UNDERFLOW) {
                                break Label_0209;
                            }
                            this.f.compact();
                            if (this.g.read(this.f) == -1) {
                                throw new IOException("connection closed unexpectedly by peer");
                            }
                            break Label_0209;
                        }
                    }
                    future = iterator.next();
                    if (future.isDone()) {
                        iterator.remove();
                        continue;
                    }
                    break;
                }
                if (!this.g.isBlocking()) {
                    return;
                }
                int n = 0;
                while (true) {
                    try {
                        try {
                            future.get();
                            if (n != 0) {
                                Thread.currentThread().interrupt();
                            }
                            return;
                        }
                        catch (ExecutionException ex) {
                            throw new RuntimeException(ex);
                        }
                        this.f.flip();
                        this.d.compact();
                        this.d();
                        if (this.h.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
                            this.a(this.i.getSession());
                            return;
                        }
                        this.e();
                        if (!com.ihs.i.i.j && this.h.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                            throw new AssertionError();
                        }
                        if (!this.c.isEmpty() && this.h.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NEED_WRAP) {
                            return;
                        }
                        this.g.write(this.a(com.ihs.i.i.a));
                        if (this.h.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
                            this.a(this.i.getSession());
                        }
                    }
                    catch (InterruptedException ex2) {
                        n = 1;
                        continue;
                    }
                    break;
                }
            }
        }
    }
    
    private ByteBuffer d() {
        synchronized (this) {
            int remaining;
            do {
                remaining = this.d.remaining();
                this.h = this.i.unwrap(this.f, this.d);
                this.k = this.h.getStatus();
            } while (this.k == SSLEngineResult.Status.OK && (remaining != this.d.remaining() || this.h.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP));
            this.d.flip();
            return this.d;
        }
    }
    
    private void e() {
        while (true) {
            final Runnable delegatedTask = this.i.getDelegatedTask();
            if (delegatedTask == null) {
                break;
            }
            this.c.add(this.b.submit(delegatedTask));
        }
    }
    
    private boolean f() {
        final SSLEngineResult.HandshakeStatus handshakeStatus = this.h.getHandshakeStatus();
        return handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED || handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
    }
    
    public final boolean a() {
        return this.g.isConnected();
    }
    
    public final Socket b() {
        return this.g.socket();
    }
    
    @Override
    public void close() {
        this.i.closeOutbound();
        this.i.getSession().invalidate();
        if (this.g.isOpen()) {
            this.g.write(this.a(com.ihs.i.i.a));
        }
        this.g.close();
    }
    
    @Override
    public boolean isOpen() {
        return this.g.isOpen();
    }
    
    @Override
    public int read(final ByteBuffer byteBuffer) {
        final boolean hasRemaining = byteBuffer.hasRemaining();
        int a = 0;
        if (hasRemaining) {
            if (!this.f()) {
                if (this.g.isBlocking()) {
                    while (!this.f()) {
                        this.c();
                    }
                }
                else {
                    this.c();
                    if (!this.f()) {
                        return 0;
                    }
                }
            }
            if (this.d.hasRemaining()) {
                a = a(this.d, byteBuffer);
            }
            else {
                if (!this.d.hasRemaining()) {
                    this.d.clear();
                }
                final boolean hasRemaining2 = this.f.hasRemaining();
                a = 0;
                if (hasRemaining2) {
                    this.d();
                    final int a2 = a(this.d, byteBuffer);
                    a = 0;
                    if (a2 > 0) {
                        a = a2;
                    }
                }
            }
            if (a == 0) {
                if (!com.ihs.i.i.j && this.d.position() != 0) {
                    throw new AssertionError();
                }
                this.d.clear();
                if (!this.f.hasRemaining()) {
                    this.f.clear();
                }
                else {
                    this.f.compact();
                }
                if (((this.g.isBlocking() && this.f.position() == 0) || this.k == SSLEngineResult.Status.BUFFER_UNDERFLOW) && this.g.read(this.f) == -1) {
                    return -1;
                }
                this.f.flip();
                this.d();
                return a(this.d, byteBuffer);
            }
        }
        return a;
    }
    
    @Override
    public int write(final ByteBuffer byteBuffer) {
        if (!this.f()) {
            this.c();
            return 0;
        }
        return this.g.write(this.a(byteBuffer));
    }
}
