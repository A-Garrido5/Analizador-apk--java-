// 
// Decompiled by Procyon v0.5.30
// 

package com.ihs.g;

import java.util.List;
import java.util.Iterator;
import java.util.Date;
import java.util.Map;

public final class d
{
    public static int a(final Map map, final String... array) {
        final Object g = g(map, array);
        if (g != null) {
            if (g instanceof Integer) {
                return (int)g;
            }
            if (g instanceof Double) {
                return (int)g;
            }
            if (g instanceof Float) {
                return (int)g;
            }
            if (g instanceof String) {
                try {
                    return Integer.parseInt(((String)g).trim());
                }
                catch (NumberFormatException ex) {}
            }
        }
        c.b("Error, Invalid Integer : " + array[-1 + array.length]);
        throw new RuntimeException("Invalid Integer config");
    }
    
    public static String a(final Map map, final String s, final String... array) {
        final String b = b(map, array);
        if (b == null) {
            return s;
        }
        return b;
    }
    
    public static Date a(final Map map, final Date date, final String... array) {
        final Object g = g(map, array);
        Date date2;
        if (g != null && g instanceof Date) {
            date2 = (Date)g;
        }
        else {
            date2 = null;
        }
        if (date2 == null) {
            return date;
        }
        return date2;
    }
    
    public static void a(final Map map, final Map map2) {
        boolean b = true;
        if (map2 == null || map == null) {
            final StringBuilder append = new StringBuilder("srcMap null = ").append(map2 == null && b).append(", destMap null = ");
            if (map != null) {
                b = false;
            }
            c.b(append.append(b).toString());
        }
        else {
            if (map2 == map) {
                c.c("srcMap & destMap are the same map, no need to merge");
                return;
            }
            for (final Map.Entry<Object, V> entry : map2.entrySet()) {
                if (!map.containsKey(entry.getKey())) {
                    map.put(entry.getKey(), entry.getValue());
                }
                else {
                    final boolean b2 = entry.getValue() instanceof Map;
                    final boolean b3 = map.get(entry.getKey()) instanceof Map;
                    if (b2 && b3) {
                        a((Map)map.get(entry.getKey()), entry.getValue());
                    }
                    else {
                        map.put(entry.getKey(), entry.getValue());
                        if (b2 == b3) {
                            continue;
                        }
                        c.b("Entry type does not match:" + entry.getKey());
                    }
                }
            }
        }
    }
    
    public static String b(final Map map, final String... array) {
        final Object g = g(map, array);
        if (g != null) {
            if (g instanceof String) {
                return (String)g;
            }
            if (g instanceof Integer || g instanceof Double || g instanceof Float) {
                return String.valueOf(g);
            }
        }
        return null;
    }
    
    public static List c(final Map map, final String... array) {
        final Object g = g(map, array);
        if (g != null && g instanceof List) {
            return (List)g;
        }
        return null;
    }
    
    public static Map d(final Map map, final String... array) {
        final Object g = g(map, array);
        if (g != null && g instanceof Map) {
            return (Map)g;
        }
        return null;
    }
    
    public static int e(final Map map, final String... array) {
        try {
            return a(map, array);
        }
        catch (RuntimeException ex) {
            return 0;
        }
    }
    
    public static boolean f(final Map map, final String... array) {
        try {
            final Object g = g(map, array);
            if (g != null && g instanceof Boolean) {
                return (boolean)g;
            }
            c.b("Error, Invalid Boolean : " + array[-1 + array.length]);
            throw new RuntimeException("Invalid Boolean config.");
        }
        catch (RuntimeException ex) {
            return false;
        }
    }
    
    private static Object g(final Map map, final String... array) {
        Object value;
        if (map == null || map.isEmpty()) {
            value = null;
        }
        else {
            final int length = array.length;
            int i = 0;
            int n = 0;
            value = map;
            while (i < length) {
                value = ((Map<K, Object>)value).get(array[i]);
                if (++n == array.length) {
                    break;
                }
                if (value == null || !(value instanceof Map)) {
                    return null;
                }
                ++i;
            }
        }
        return value;
    }
}
