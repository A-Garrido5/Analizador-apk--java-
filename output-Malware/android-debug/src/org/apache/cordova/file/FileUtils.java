// 
// Decompiled by Procyon v0.5.30
// 

package org.apache.cordova.file;

import java.util.HashSet;
import org.apache.cordova.CordovaWebView;
import org.apache.cordova.CordovaInterface;
import android.content.Context;
import java.util.HashMap;
import org.apache.cordova.PluginResult;
import org.apache.cordova.CallbackContext;
import android.net.Uri;
import android.app.Activity;
import android.util.Log;
import android.os.Environment;
import java.io.File;
import java.util.Iterator;
import java.net.MalformedURLException;
import org.json.JSONObject;
import org.json.JSONException;
import org.json.JSONArray;
import java.io.IOException;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import org.apache.cordova.CordovaPlugin;

public class FileUtils extends CordovaPlugin
{
    public static int ABORT_ERR = 0;
    public static int ENCODING_ERR = 0;
    public static int INVALID_MODIFICATION_ERR = 0;
    public static int INVALID_STATE_ERR = 0;
    private static final String LOG_TAG = "FileUtils";
    public static int NOT_FOUND_ERR;
    public static int NOT_READABLE_ERR;
    public static int NO_MODIFICATION_ALLOWED_ERR;
    public static int PATH_EXISTS_ERR;
    public static int QUOTA_EXCEEDED_ERR;
    public static int SECURITY_ERR;
    public static int SYNTAX_ERR;
    public static int TYPE_MISMATCH_ERR;
    public static int UNKNOWN_ERR;
    private static FileUtils filePlugin;
    private boolean configured;
    private ArrayList<Filesystem> filesystems;
    
    static {
        FileUtils.NOT_FOUND_ERR = 1;
        FileUtils.SECURITY_ERR = 2;
        FileUtils.ABORT_ERR = 3;
        FileUtils.NOT_READABLE_ERR = 4;
        FileUtils.ENCODING_ERR = 5;
        FileUtils.NO_MODIFICATION_ALLOWED_ERR = 6;
        FileUtils.INVALID_STATE_ERR = 7;
        FileUtils.SYNTAX_ERR = 8;
        FileUtils.INVALID_MODIFICATION_ERR = 9;
        FileUtils.QUOTA_EXCEEDED_ERR = 10;
        FileUtils.TYPE_MISMATCH_ERR = 11;
        FileUtils.PATH_EXISTS_ERR = 12;
        FileUtils.UNKNOWN_ERR = 1000;
    }
    
    public FileUtils() {
        this.configured = false;
    }
    
    private Filesystem filesystemForName(final String s) {
        for (final Filesystem filesystem : this.filesystems) {
            if (filesystem != null && filesystem.name != null && filesystem.name.equals(s)) {
                return filesystem;
            }
        }
        return null;
    }
    
    private Filesystem filesystemForURL(final LocalFilesystemURL localFilesystemURL) {
        if (localFilesystemURL == null) {
            return null;
        }
        return this.filesystemForName(localFilesystemURL.fsName);
    }
    
    @Deprecated
    public static JSONObject getEntry(final File file) throws JSONException {
        if (getFilePlugin() != null) {
            return getFilePlugin().getEntryForFile(file);
        }
        return null;
    }
    
    private JSONObject getFile(final String s, final String s2, final JSONObject jsonObject, final boolean b) throws FileExistsException, IOException, TypeMismatchException, EncodingException, JSONException {
        LocalFilesystemURL parse;
        Filesystem filesystemForURL;
        try {
            parse = LocalFilesystemURL.parse(s);
            filesystemForURL = this.filesystemForURL(parse);
            if (filesystemForURL == null) {
                throw new MalformedURLException("No installed handlers for this URL");
            }
        }
        catch (IllegalArgumentException ex) {
            throw new MalformedURLException("Unrecognized filesystem URL");
        }
        return filesystemForURL.getFileForLocalURL(parse, s2, jsonObject, b);
    }
    
    private JSONObject getFileMetadata(final String s) throws FileNotFoundException, JSONException, MalformedURLException {
        LocalFilesystemURL parse;
        Filesystem filesystemForURL;
        try {
            parse = LocalFilesystemURL.parse(s);
            filesystemForURL = this.filesystemForURL(parse);
            if (filesystemForURL == null) {
                throw new MalformedURLException("No installed handlers for this URL");
            }
        }
        catch (IllegalArgumentException ex) {
            throw new MalformedURLException("Unrecognized filesystem URL");
        }
        return filesystemForURL.getFileMetadataForLocalURL(parse);
    }
    
    public static FileUtils getFilePlugin() {
        return FileUtils.filePlugin;
    }
    
    private JSONObject getParent(final String s) throws JSONException, IOException {
        LocalFilesystemURL parse;
        Filesystem filesystemForURL;
        try {
            parse = LocalFilesystemURL.parse(s);
            filesystemForURL = this.filesystemForURL(parse);
            if (filesystemForURL == null) {
                throw new MalformedURLException("No installed handlers for this URL");
            }
        }
        catch (IllegalArgumentException ex) {
            throw new MalformedURLException("Unrecognized filesystem URL");
        }
        return filesystemForURL.getParentForLocalURL(parse);
    }
    
    private JSONArray readEntries(final String s) throws FileNotFoundException, JSONException, MalformedURLException {
        LocalFilesystemURL parse;
        Filesystem filesystemForURL;
        try {
            parse = LocalFilesystemURL.parse(s);
            filesystemForURL = this.filesystemForURL(parse);
            if (filesystemForURL == null) {
                throw new MalformedURLException("No installed handlers for this URL");
            }
        }
        catch (IllegalArgumentException ex) {
            throw new MalformedURLException("Unrecognized filesystem URL");
        }
        return filesystemForURL.readEntriesAtLocalURL(parse);
    }
    
    private boolean remove(final String s) throws NoModificationAllowedException, InvalidModificationException, MalformedURLException {
        LocalFilesystemURL parse;
        try {
            parse = LocalFilesystemURL.parse(s);
            if ("".equals(parse.path) || "/".equals(parse.path)) {
                throw new NoModificationAllowedException("You can't delete the root directory");
            }
        }
        catch (IllegalArgumentException ex) {
            throw new MalformedURLException("Unrecognized filesystem URL");
        }
        final Filesystem filesystemForURL = this.filesystemForURL(parse);
        if (filesystemForURL == null) {
            throw new MalformedURLException("No installed handlers for this URL");
        }
        return filesystemForURL.removeFileAtLocalURL(parse);
    }
    
    private boolean removeRecursively(final String s) throws FileExistsException, NoModificationAllowedException, MalformedURLException {
        LocalFilesystemURL parse;
        try {
            parse = LocalFilesystemURL.parse(s);
            if ("".equals(parse.path) || "/".equals(parse.path)) {
                throw new NoModificationAllowedException("You can't delete the root directory");
            }
        }
        catch (IllegalArgumentException ex) {
            throw new MalformedURLException("Unrecognized filesystem URL");
        }
        final Filesystem filesystemForURL = this.filesystemForURL(parse);
        if (filesystemForURL == null) {
            throw new MalformedURLException("No installed handlers for this URL");
        }
        return filesystemForURL.recursiveRemoveFileAtLocalURL(parse);
    }
    
    private JSONArray requestAllFileSystems() throws IOException, JSONException {
        final JSONArray jsonArray = new JSONArray();
        final Iterator<Filesystem> iterator = this.filesystems.iterator();
        while (iterator.hasNext()) {
            jsonArray.put((Object)iterator.next().getRootEntry());
        }
        return jsonArray;
    }
    
    private JSONObject requestAllPaths() throws JSONException {
        final Activity activity = this.cordova.getActivity();
        final JSONObject jsonObject = new JSONObject();
        jsonObject.put("applicationDirectory", (Object)"file:///android_asset/");
        jsonObject.put("applicationStorageDirectory", (Object)toDirUrl(((Context)activity).getFilesDir().getParentFile()));
        jsonObject.put("dataDirectory", (Object)toDirUrl(((Context)activity).getFilesDir()));
        jsonObject.put("cacheDirectory", (Object)toDirUrl(((Context)activity).getCacheDir()));
        if (!Environment.getExternalStorageState().equals("mounted")) {
            return jsonObject;
        }
        try {
            jsonObject.put("externalApplicationStorageDirectory", (Object)toDirUrl(((Context)activity).getExternalFilesDir((String)null).getParentFile()));
            jsonObject.put("externalDataDirectory", (Object)toDirUrl(((Context)activity).getExternalFilesDir((String)null)));
            jsonObject.put("externalCacheDirectory", (Object)toDirUrl(((Context)activity).getExternalCacheDir()));
            jsonObject.put("externalRootDirectory", (Object)toDirUrl(Environment.getExternalStorageDirectory()));
            return jsonObject;
        }
        catch (NullPointerException ex) {
            Log.d("FileUtils", "Unable to access these paths, most liklely due to USB storage");
            return jsonObject;
        }
    }
    
    private JSONObject requestFileSystem(final int n) throws IOException, JSONException {
        final JSONObject jsonObject = new JSONObject();
        Filesystem filesystem;
        while (true) {
            try {
                filesystem = this.filesystems.get(n);
                if (filesystem == null) {
                    throw new IOException("No filesystem of type requested");
                }
            }
            catch (ArrayIndexOutOfBoundsException ex) {
                filesystem = null;
                continue;
            }
            break;
        }
        jsonObject.put("name", (Object)filesystem.name);
        jsonObject.put("root", (Object)filesystem.getRootEntry());
        return jsonObject;
    }
    
    private JSONObject resolveLocalFileSystemURI(final String s) throws IOException, JSONException {
        if (s == null) {
            throw new MalformedURLException("Unrecognized filesystem URL");
        }
        final Uri parse = Uri.parse(s);
        LocalFilesystemURL localFilesystemURL = LocalFilesystemURL.parse(parse);
        if (localFilesystemURL == null) {
            localFilesystemURL = this.resolveNativeUri(parse);
        }
        final LocalFilesystemURL localFilesystemURL2 = localFilesystemURL;
        Filesystem filesystemForURL;
        try {
            filesystemForURL = this.filesystemForURL(localFilesystemURL2);
            if (filesystemForURL == null) {
                throw new MalformedURLException("No installed handlers for this URL");
            }
        }
        catch (IllegalArgumentException ex) {
            throw new MalformedURLException("Unrecognized filesystem URL");
        }
        if (filesystemForURL.exists(localFilesystemURL)) {
            return filesystemForURL.getEntryForLocalURL(localFilesystemURL);
        }
        throw new FileNotFoundException();
    }
    
    private void threadhelper(final FileOp fileOp, final String s, final CallbackContext callbackContext) {
        this.cordova.getThreadPool().execute(new Runnable() {
            @Override
            public void run() {
                try {
                    fileOp.run(new JSONArray(s));
                }
                catch (Exception ex) {
                    if (ex instanceof EncodingException) {
                        callbackContext.error(FileUtils.ENCODING_ERR);
                        return;
                    }
                    if (ex instanceof FileNotFoundException) {
                        callbackContext.error(FileUtils.NOT_FOUND_ERR);
                        return;
                    }
                    if (ex instanceof FileExistsException) {
                        callbackContext.error(FileUtils.PATH_EXISTS_ERR);
                        return;
                    }
                    if (ex instanceof NoModificationAllowedException) {
                        callbackContext.error(FileUtils.NO_MODIFICATION_ALLOWED_ERR);
                        return;
                    }
                    if (ex instanceof InvalidModificationException) {
                        callbackContext.error(FileUtils.INVALID_MODIFICATION_ERR);
                        return;
                    }
                    if (ex instanceof MalformedURLException) {
                        callbackContext.error(FileUtils.ENCODING_ERR);
                        return;
                    }
                    if (ex instanceof IOException) {
                        callbackContext.error(FileUtils.INVALID_MODIFICATION_ERR);
                        return;
                    }
                    if (ex instanceof EncodingException) {
                        callbackContext.error(FileUtils.ENCODING_ERR);
                        return;
                    }
                    if (ex instanceof TypeMismatchException) {
                        callbackContext.error(FileUtils.TYPE_MISMATCH_ERR);
                        return;
                    }
                    if (ex instanceof JSONException) {
                        callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.JSON_EXCEPTION));
                        return;
                    }
                    ex.printStackTrace();
                    callbackContext.error(FileUtils.UNKNOWN_ERR);
                }
            }
        });
    }
    
    private static String toDirUrl(final File file) {
        return Uri.fromFile(file).toString() + '/';
    }
    
    private JSONObject transferTo(final String s, final String s2, final String s3, final boolean b) throws JSONException, NoModificationAllowedException, IOException, InvalidModificationException, EncodingException, FileExistsException {
        if (s == null || s2 == null) {
            throw new FileNotFoundException();
        }
        final LocalFilesystemURL parse = LocalFilesystemURL.parse(s);
        final LocalFilesystemURL parse2 = LocalFilesystemURL.parse(s2);
        final Filesystem filesystemForURL = this.filesystemForURL(parse);
        final Filesystem filesystemForURL2 = this.filesystemForURL(parse2);
        if (s3 != null && s3.contains(":")) {
            throw new EncodingException("Bad file name");
        }
        return filesystemForURL2.copyFileToURL(parse2, s3, filesystemForURL, parse, b);
    }
    
    private long truncateFile(final String s, final long n) throws FileNotFoundException, IOException, NoModificationAllowedException {
        LocalFilesystemURL parse;
        Filesystem filesystemForURL;
        try {
            parse = LocalFilesystemURL.parse(s);
            filesystemForURL = this.filesystemForURL(parse);
            if (filesystemForURL == null) {
                throw new MalformedURLException("No installed handlers for this URL");
            }
        }
        catch (IllegalArgumentException ex) {
            throw new MalformedURLException("Unrecognized filesystem URL");
        }
        return filesystemForURL.truncateFileAtURL(parse, n);
    }
    
    @Override
    public boolean execute(final String s, final String s2, final CallbackContext callbackContext) {
        if (!this.configured) {
            callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.ERROR, "File plugin is not configured. Please see the README.md file for details on how to update config.xml"));
            return true;
        }
        if (s.equals("testSaveLocationExists")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) {
                    callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.OK, DirectoryManager.testSaveLocationExists()));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("getFreeDiskSpace")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) {
                    callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.OK, DirectoryManager.getFreeDiskSpace(false)));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("testFileExists")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws JSONException {
                    callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.OK, DirectoryManager.testFileExists(jsonArray.getString(0))));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("testDirectoryExists")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws JSONException {
                    callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.OK, DirectoryManager.testFileExists(jsonArray.getString(0))));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("readAsText")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws JSONException, MalformedURLException {
                    FileUtils.this.readFileAs(jsonArray.getString(0), jsonArray.getInt(2), jsonArray.getInt(3), callbackContext, jsonArray.getString(1), 1);
                }
            }, s2, callbackContext);
        }
        else if (s.equals("readAsDataURL")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws JSONException, MalformedURLException {
                    FileUtils.this.readFileAs(jsonArray.getString(0), jsonArray.getInt(1), jsonArray.getInt(2), callbackContext, null, -1);
                }
            }, s2, callbackContext);
        }
        else if (s.equals("readAsArrayBuffer")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws JSONException, MalformedURLException {
                    FileUtils.this.readFileAs(jsonArray.getString(0), jsonArray.getInt(1), jsonArray.getInt(2), callbackContext, null, 6);
                }
            }, s2, callbackContext);
        }
        else if (s.equals("readAsBinaryString")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws JSONException, MalformedURLException {
                    FileUtils.this.readFileAs(jsonArray.getString(0), jsonArray.getInt(1), jsonArray.getInt(2), callbackContext, null, 7);
                }
            }, s2, callbackContext);
        }
        else if (s.equals("write")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws JSONException, FileNotFoundException, IOException, NoModificationAllowedException {
                    callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.OK, FileUtils.this.write(jsonArray.getString(0), jsonArray.getString(1), jsonArray.getInt(2), Boolean.valueOf(jsonArray.getBoolean(3)))));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("truncate")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws JSONException, FileNotFoundException, IOException, NoModificationAllowedException {
                    callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.OK, FileUtils.this.truncateFile(jsonArray.getString(0), jsonArray.getInt(1))));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("requestAllFileSystems")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws IOException, JSONException {
                    callbackContext.success(FileUtils.this.requestAllFileSystems());
                }
            }, s2, callbackContext);
        }
        else if (s.equals("requestAllPaths")) {
            this.cordova.getThreadPool().execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        callbackContext.success(FileUtils.this.requestAllPaths());
                    }
                    catch (JSONException ex) {
                        ex.printStackTrace();
                    }
                }
            });
        }
        else if (s.equals("requestFileSystem")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws IOException, JSONException {
                    final int int1 = jsonArray.getInt(0);
                    final long optLong = jsonArray.optLong(1);
                    if (optLong != 0L && optLong > 1024L * DirectoryManager.getFreeDiskSpace(true)) {
                        callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.ERROR, FileUtils.QUOTA_EXCEEDED_ERR));
                        return;
                    }
                    callbackContext.success(FileUtils.this.requestFileSystem(int1));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("resolveLocalFileSystemURI")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws IOException, JSONException {
                    callbackContext.success(FileUtils.this.resolveLocalFileSystemURI(jsonArray.getString(0)));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("getFileMetadata")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws FileNotFoundException, JSONException, MalformedURLException {
                    callbackContext.success(FileUtils.this.getFileMetadata(jsonArray.getString(0)));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("getParent")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws JSONException, IOException {
                    callbackContext.success(FileUtils.this.getParent(jsonArray.getString(0)));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("getDirectory")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws FileExistsException, IOException, TypeMismatchException, EncodingException, JSONException {
                    callbackContext.success(FileUtils.this.getFile(jsonArray.getString(0), jsonArray.getString(1), jsonArray.optJSONObject(2), true));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("getFile")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws FileExistsException, IOException, TypeMismatchException, EncodingException, JSONException {
                    callbackContext.success(FileUtils.this.getFile(jsonArray.getString(0), jsonArray.getString(1), jsonArray.optJSONObject(2), false));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("remove")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws JSONException, NoModificationAllowedException, InvalidModificationException, MalformedURLException {
                    if (FileUtils.this.remove(jsonArray.getString(0))) {
                        callbackContext.success();
                        return;
                    }
                    callbackContext.error(FileUtils.NO_MODIFICATION_ALLOWED_ERR);
                }
            }, s2, callbackContext);
        }
        else if (s.equals("removeRecursively")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws JSONException, FileExistsException, MalformedURLException, NoModificationAllowedException {
                    if (FileUtils.this.removeRecursively(jsonArray.getString(0))) {
                        callbackContext.success();
                        return;
                    }
                    callbackContext.error(FileUtils.NO_MODIFICATION_ALLOWED_ERR);
                }
            }, s2, callbackContext);
        }
        else if (s.equals("moveTo")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws JSONException, NoModificationAllowedException, IOException, InvalidModificationException, EncodingException, FileExistsException {
                    callbackContext.success(FileUtils.this.transferTo(jsonArray.getString(0), jsonArray.getString(1), jsonArray.getString(2), true));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("copyTo")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws JSONException, NoModificationAllowedException, IOException, InvalidModificationException, EncodingException, FileExistsException {
                    callbackContext.success(FileUtils.this.transferTo(jsonArray.getString(0), jsonArray.getString(1), jsonArray.getString(2), false));
                }
            }, s2, callbackContext);
        }
        else if (s.equals("readEntries")) {
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws FileNotFoundException, JSONException, MalformedURLException {
                    callbackContext.success(FileUtils.this.readEntries(jsonArray.getString(0)));
                }
            }, s2, callbackContext);
        }
        else {
            if (!s.equals("_getLocalFilesystemPath")) {
                return false;
            }
            this.threadhelper((FileOp)new FileOp() {
                @Override
                public void run(final JSONArray jsonArray) throws FileNotFoundException, JSONException, MalformedURLException {
                    callbackContext.success(FileUtils.this.filesystemPathForURL(jsonArray.getString(0)));
                }
            }, s2, callbackContext);
        }
        return true;
    }
    
    public String filesystemPathForURL(final String s) throws MalformedURLException {
        LocalFilesystemURL parse;
        Filesystem filesystemForURL;
        try {
            parse = LocalFilesystemURL.parse(s);
            filesystemForURL = this.filesystemForURL(parse);
            if (filesystemForURL == null) {
                throw new MalformedURLException("No installed handlers for this URL");
            }
        }
        catch (IllegalArgumentException ex) {
            throw new MalformedURLException("Unrecognized filesystem URL");
        }
        return filesystemForURL.filesystemPathForURL(parse);
    }
    
    public LocalFilesystemURL filesystemURLforLocalPath(final String s) {
        LocalFilesystemURL localFilesystemURL = null;
        int length = 0;
        final Iterator<Filesystem> iterator = this.filesystems.iterator();
        while (iterator.hasNext()) {
            final LocalFilesystemURL urLforFilesystemPath = iterator.next().URLforFilesystemPath(s);
            if (urLforFilesystemPath != null && (localFilesystemURL == null || urLforFilesystemPath.path.length() < length)) {
                localFilesystemURL = urLforFilesystemPath;
                length = urLforFilesystemPath.path.length();
            }
        }
        return localFilesystemURL;
    }
    
    protected HashMap<String, String> getAvailableFileSystems(final Activity activity) {
        final Context applicationContext = activity.getApplicationContext();
        final HashMap<String, String> hashMap = new HashMap<String, String>();
        hashMap.put("files", applicationContext.getFilesDir().getAbsolutePath());
        hashMap.put("documents", new File(applicationContext.getFilesDir(), "Documents").getAbsolutePath());
        hashMap.put("cache", applicationContext.getCacheDir().getAbsolutePath());
        hashMap.put("root", "/");
        if (!Environment.getExternalStorageState().equals("mounted")) {
            return hashMap;
        }
        try {
            hashMap.put("files-external", applicationContext.getExternalFilesDir((String)null).getAbsolutePath());
            hashMap.put("sdcard", Environment.getExternalStorageDirectory().getAbsolutePath());
            hashMap.put("cache-external", applicationContext.getExternalCacheDir().getAbsolutePath());
            return hashMap;
        }
        catch (NullPointerException ex) {
            Log.d("FileUtils", "External storage unavailable, check to see if USB Mass Storage Mode is on");
            return hashMap;
        }
    }
    
    public JSONObject getEntryForFile(final File file) throws JSONException {
        final Iterator<Filesystem> iterator = this.filesystems.iterator();
        while (iterator.hasNext()) {
            final JSONObject entryForFile = iterator.next().makeEntryForFile(file);
            if (entryForFile != null) {
                return entryForFile;
            }
        }
        return null;
    }
    
    protected String[] getExtraFileSystemsPreference(final Activity activity) {
        return this.preferences.getString("androidextrafilesystems", "files,files-external,documents,sdcard,cache,cache-external,root").split(",");
    }
    
    @Override
    public void initialize(final CordovaInterface cordovaInterface, final CordovaWebView cordovaWebView) {
        super.initialize(cordovaInterface, cordovaWebView);
        this.filesystems = new ArrayList<Filesystem>();
        final Activity activity = cordovaInterface.getActivity();
        final String packageName = activity.getPackageName();
        final String string = this.preferences.getString("androidpersistentfilelocation", "internal");
        String s = activity.getCacheDir().getAbsolutePath();
        String s2;
        if ("internal".equalsIgnoreCase(string)) {
            s2 = activity.getFilesDir().getAbsolutePath() + "/files/";
            this.configured = true;
        }
        else {
            final boolean equalsIgnoreCase = "compatibility".equalsIgnoreCase(string);
            s2 = null;
            if (equalsIgnoreCase) {
                if (Environment.getExternalStorageState().equals("mounted")) {
                    s2 = Environment.getExternalStorageDirectory().getAbsolutePath();
                    s = Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + packageName + "/cache/";
                }
                else {
                    s2 = "/data/data/" + packageName;
                }
                this.configured = true;
            }
        }
        if (this.configured) {
            final File file = new File(s);
            final File file2 = new File(s2);
            file.mkdirs();
            file2.mkdirs();
            this.registerFilesystem(new LocalFilesystem("temporary", cordovaWebView.getContext(), cordovaWebView.getResourceApi(), file));
            this.registerFilesystem(new LocalFilesystem("persistent", cordovaWebView.getContext(), cordovaWebView.getResourceApi(), file2));
            this.registerFilesystem(new ContentFilesystem(cordovaWebView.getContext(), cordovaWebView.getResourceApi()));
            this.registerFilesystem(new AssetFilesystem(cordovaWebView.getContext().getAssets(), cordovaWebView.getResourceApi()));
            this.registerExtraFileSystems(this.getExtraFileSystemsPreference(activity), this.getAvailableFileSystems(activity));
            if (FileUtils.filePlugin == null) {
                FileUtils.filePlugin = this;
            }
            return;
        }
        Log.e("FileUtils", "File plugin configuration error: Please set AndroidPersistentFileLocation in config.xml to one of \"internal\" (for new applications) or \"compatibility\" (for compatibility with previous versions)");
        activity.finish();
    }
    
    public void readFileAs(final String s, final int n, final int n2, final CallbackContext callbackContext, final String s2, final int n3) throws MalformedURLException {
        try {
            if (this.filesystemForURL(LocalFilesystemURL.parse(s)) == null) {
                throw new MalformedURLException("No installed handlers for this URL");
            }
            goto Label_0049;
        }
        catch (IllegalArgumentException ex2) {
            throw new MalformedURLException("Unrecognized filesystem URL");
        }
        catch (FileNotFoundException ex3) {
            callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.IO_EXCEPTION, FileUtils.NOT_FOUND_ERR));
        }
        catch (IOException ex) {
            Log.d("FileUtils", ex.getLocalizedMessage());
            callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.IO_EXCEPTION, FileUtils.NOT_READABLE_ERR));
        }
    }
    
    protected void registerExtraFileSystems(final String[] array, final HashMap<String, String> hashMap) {
        final HashSet<String> set = new HashSet<String>();
        for (final String s : array) {
            if (!set.contains(s)) {
                final String s2 = hashMap.get(s);
                if (s2 != null) {
                    final File file = new File(s2);
                    if (file.mkdirs() || file.isDirectory()) {
                        this.registerFilesystem(new LocalFilesystem(s, this.webView.getContext(), this.webView.getResourceApi(), file));
                        set.add(s);
                    }
                    else {
                        Log.d("FileUtils", "Unable to create root dir for filesystem \"" + s + "\", skipping");
                    }
                }
                else {
                    Log.d("FileUtils", "Unrecognized extra filesystem identifier: " + s);
                }
            }
        }
    }
    
    public void registerFilesystem(final Filesystem filesystem) {
        if (filesystem != null && this.filesystemForName(filesystem.name) == null) {
            this.filesystems.add(filesystem);
        }
    }
    
    @Override
    public Uri remapUri(final Uri uri) {
        if (!"cdvfile".equals(uri.getScheme())) {
            return null;
        }
        try {
            final LocalFilesystemURL parse = LocalFilesystemURL.parse(uri);
            final Filesystem filesystemForURL = this.filesystemForURL(parse);
            if (filesystemForURL == null) {
                return null;
            }
            if (filesystemForURL.filesystemPathForURL(parse) != null) {
                return Uri.parse("file://" + filesystemForURL.filesystemPathForURL(parse));
            }
            return null;
        }
        catch (IllegalArgumentException ex) {
            return null;
        }
    }
    
    public LocalFilesystemURL resolveNativeUri(final Uri uri) {
        LocalFilesystemURL localFilesystemURL = null;
        final Iterator<Filesystem> iterator = this.filesystems.iterator();
        while (iterator.hasNext()) {
            final LocalFilesystemURL localUri = iterator.next().toLocalUri(uri);
            if (localUri != null && (localFilesystemURL == null || localUri.uri.toString().length() < localFilesystemURL.toString().length())) {
                localFilesystemURL = localUri;
            }
        }
        return localFilesystemURL;
    }
    
    public long write(final String s, final String s2, final int n, final boolean b) throws FileNotFoundException, IOException, NoModificationAllowedException {
        LocalFilesystemURL parse;
        Filesystem filesystemForURL;
        try {
            parse = LocalFilesystemURL.parse(s);
            filesystemForURL = this.filesystemForURL(parse);
            if (filesystemForURL == null) {
                throw new MalformedURLException("No installed handlers for this URL");
            }
        }
        catch (IllegalArgumentException ex) {
            throw new MalformedURLException("Unrecognized filesystem URL");
        }
        final long writeToFileAtURL = filesystemForURL.writeToFileAtURL(parse, s2, n, b);
        Log.d("TEST", s + ": " + writeToFileAtURL);
        return writeToFileAtURL;
    }
    
    private interface FileOp
    {
        void run(final JSONArray p0) throws Exception;
    }
}
