// 
// Decompiled by Procyon v0.5.30
// 

package org.apache.cordova.file;

import java.io.FilterInputStream;
import java.io.InputStream;
import org.json.JSONArray;
import java.io.File;
import java.io.OutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Iterator;
import java.util.Collection;
import java.util.ArrayList;
import java.util.Arrays;
import org.json.JSONException;
import android.net.Uri;
import org.json.JSONObject;
import org.apache.cordova.CordovaResourceApi;

public abstract class Filesystem
{
    public final String name;
    protected final CordovaResourceApi resourceApi;
    private JSONObject rootEntry;
    protected final Uri rootUri;
    
    public Filesystem(final Uri rootUri, final String name, final CordovaResourceApi resourceApi) {
        this.rootUri = rootUri;
        this.name = name;
        this.resourceApi = resourceApi;
    }
    
    public static JSONObject makeEntryForURL(final LocalFilesystemURL localFilesystemURL, final Uri uri) {
        try {
            final String path = localFilesystemURL.path;
            int n;
            if (path.endsWith("/")) {
                n = 1;
            }
            else {
                n = 0;
            }
            final String[] split = path.substring(0, path.length() - n).split("/+");
            final String s = split[-1 + split.length];
            final JSONObject jsonObject = new JSONObject();
            jsonObject.put("isFile", !localFilesystemURL.isDirectory);
            jsonObject.put("isDirectory", localFilesystemURL.isDirectory);
            jsonObject.put("name", (Object)s);
            jsonObject.put("fullPath", (Object)path);
            jsonObject.put("filesystemName", (Object)localFilesystemURL.fsName);
            int n2;
            if ("temporary".equals(localFilesystemURL.fsName)) {
                n2 = 0;
            }
            else {
                n2 = 1;
            }
            jsonObject.put("filesystem", n2);
            String s2 = uri.toString();
            if (localFilesystemURL.isDirectory && !s2.endsWith("/")) {
                s2 += "/";
            }
            jsonObject.put("nativeURL", (Object)s2);
            return jsonObject;
        }
        catch (JSONException ex) {
            ex.printStackTrace();
            throw new RuntimeException((Throwable)ex);
        }
    }
    
    protected static String normalizePath(final String s) {
        String replaceFirst = s;
        final boolean startsWith = replaceFirst.startsWith("/");
        if (startsWith) {
            replaceFirst = replaceFirst.replaceFirst("/+", "");
        }
        final ArrayList list = new ArrayList<String>(Arrays.asList(replaceFirst.split("/+")));
        for (int i = 0; i < list.size(); ++i) {
            if (list.get(i).equals("..")) {
                list.remove(i);
                if (i > 0) {
                    list.remove(-1 + i);
                    --i;
                }
            }
        }
        final StringBuilder sb = new StringBuilder();
        for (final String s2 : list) {
            sb.append("/");
            sb.append(s2);
        }
        if (startsWith) {
            return sb.toString();
        }
        return sb.toString().substring(1);
    }
    
    abstract LocalFilesystemURL URLforFilesystemPath(final String p0);
    
    abstract boolean canRemoveFileAtLocalURL(final LocalFilesystemURL p0);
    
    public JSONObject copyFileToURL(final LocalFilesystemURL localFilesystemURL, final String s, final Filesystem filesystem, final LocalFilesystemURL localFilesystemURL2, final boolean b) throws IOException, InvalidModificationException, JSONException, NoModificationAllowedException, FileExistsException {
        if (b && !filesystem.canRemoveFileAtLocalURL(localFilesystemURL2)) {
            throw new NoModificationAllowedException("Cannot move file at source URL");
        }
        final LocalFilesystemURL destinationURL = this.makeDestinationURL(s, localFilesystemURL2, localFilesystemURL, localFilesystemURL2.isDirectory);
        final CordovaResourceApi.OpenForReadResult openForRead = this.resourceApi.openForRead(filesystem.toNativeUri(localFilesystemURL2));
        try {
            this.resourceApi.copyResource(openForRead, this.getOutputStreamForURL(destinationURL));
            if (b) {
                filesystem.removeFileAtLocalURL(localFilesystemURL2);
            }
            return this.getEntryForLocalURL(destinationURL);
        }
        catch (IOException ex) {
            openForRead.inputStream.close();
            throw ex;
        }
    }
    
    public boolean exists(final LocalFilesystemURL localFilesystemURL) {
        try {
            this.getFileMetadataForLocalURL(localFilesystemURL);
            return true;
        }
        catch (FileNotFoundException ex) {
            return false;
        }
    }
    
    abstract String filesystemPathForURL(final LocalFilesystemURL p0);
    
    public JSONObject getEntryForLocalURL(final LocalFilesystemURL localFilesystemURL) throws IOException {
        return this.makeEntryForURL(localFilesystemURL);
    }
    
    abstract JSONObject getFileForLocalURL(final LocalFilesystemURL p0, final String p1, final JSONObject p2, final boolean p3) throws FileExistsException, IOException, TypeMismatchException, EncodingException, JSONException;
    
    abstract JSONObject getFileMetadataForLocalURL(final LocalFilesystemURL p0) throws FileNotFoundException;
    
    public OutputStream getOutputStreamForURL(final LocalFilesystemURL localFilesystemURL) throws IOException {
        return this.resourceApi.openOutputStream(this.toNativeUri(localFilesystemURL));
    }
    
    public JSONObject getParentForLocalURL(final LocalFilesystemURL localFilesystemURL) throws IOException {
        Uri uri = localFilesystemURL.uri;
        final String parent = new File(localFilesystemURL.uri.getPath()).getParent();
        if (!"/".equals(parent)) {
            uri = localFilesystemURL.uri.buildUpon().path(parent + '/').build();
        }
        return this.getEntryForLocalURL(LocalFilesystemURL.parse(uri));
    }
    
    public JSONObject getRootEntry() {
        if (this.rootEntry == null) {
            this.rootEntry = this.makeEntryForNativeUri(this.rootUri);
        }
        return this.rootEntry;
    }
    
    public Uri getRootUri() {
        return this.rootUri;
    }
    
    abstract LocalFilesystemURL[] listChildren(final LocalFilesystemURL p0) throws FileNotFoundException;
    
    public LocalFilesystemURL localUrlforFullPath(final String s) {
        final Uri nativeUriForFullPath = this.nativeUriForFullPath(s);
        if (nativeUriForFullPath != null) {
            return this.toLocalUri(nativeUriForFullPath);
        }
        return null;
    }
    
    protected LocalFilesystemURL makeDestinationURL(final String s, final LocalFilesystemURL localFilesystemURL, final LocalFilesystemURL localFilesystemURL2, final boolean b) {
        String lastPathSegment = s;
        if ("null".equals(lastPathSegment) || "".equals(lastPathSegment)) {
            lastPathSegment = localFilesystemURL.uri.getLastPathSegment();
        }
        final String string = localFilesystemURL2.uri.toString();
        String s2;
        if (string.endsWith("/")) {
            s2 = string + lastPathSegment;
        }
        else {
            s2 = string + "/" + lastPathSegment;
        }
        if (b) {
            s2 += '/';
        }
        return LocalFilesystemURL.parse(s2);
    }
    
    public JSONObject makeEntryForFile(final File file) {
        return this.makeEntryForNativeUri(Uri.fromFile(file));
    }
    
    public JSONObject makeEntryForNativeUri(final Uri uri) {
        final LocalFilesystemURL localUri = this.toLocalUri(uri);
        JSONObject entryForURL;
        if (localUri == null) {
            entryForURL = null;
        }
        else {
            entryForURL = makeEntryForURL(localUri, uri);
        }
        return entryForURL;
    }
    
    public JSONObject makeEntryForURL(final LocalFilesystemURL localFilesystemURL) {
        final Uri nativeUri = this.toNativeUri(localFilesystemURL);
        JSONObject entryForURL;
        if (nativeUri == null) {
            entryForURL = null;
        }
        else {
            entryForURL = makeEntryForURL(localFilesystemURL, nativeUri);
        }
        return entryForURL;
    }
    
    public Uri nativeUriForFullPath(final String s) {
        Uri build = null;
        if (s != null) {
            String s2 = Uri.fromFile(new File(s)).getEncodedPath();
            if (s2.startsWith("/")) {
                s2 = s2.substring(1);
            }
            build = this.rootUri.buildUpon().appendEncodedPath(s2).build();
        }
        return build;
    }
    
    public final JSONArray readEntriesAtLocalURL(final LocalFilesystemURL localFilesystemURL) throws FileNotFoundException {
        final LocalFilesystemURL[] listChildren = this.listChildren(localFilesystemURL);
        final JSONArray jsonArray = new JSONArray();
        if (listChildren != null) {
            for (int length = listChildren.length, i = 0; i < length; ++i) {
                jsonArray.put((Object)this.makeEntryForURL(listChildren[i]));
            }
        }
        return jsonArray;
    }
    
    public void readFileAtURL(final LocalFilesystemURL localFilesystemURL, final long n, final long n2, final ReadFileCallback readFileCallback) throws IOException {
        long length = n2;
        final CordovaResourceApi.OpenForReadResult openForRead = this.resourceApi.openForRead(this.toNativeUri(localFilesystemURL));
        if (length < 0L) {
            length = openForRead.length;
        }
        final long n3 = length - n;
        Label_0054: {
            if (n <= 0L) {
                break Label_0054;
            }
            try {
                openForRead.inputStream.skip(n);
                InputStream inputStream = openForRead.inputStream;
                if (length < openForRead.length) {
                    inputStream = new LimitedInputStream(inputStream, n3);
                }
                readFileCallback.handleData(inputStream, openForRead.mimeType);
            }
            finally {
                openForRead.inputStream.close();
            }
        }
    }
    
    abstract boolean recursiveRemoveFileAtLocalURL(final LocalFilesystemURL p0) throws FileExistsException, NoModificationAllowedException;
    
    abstract boolean removeFileAtLocalURL(final LocalFilesystemURL p0) throws InvalidModificationException, NoModificationAllowedException;
    
    public abstract LocalFilesystemURL toLocalUri(final Uri p0);
    
    public abstract Uri toNativeUri(final LocalFilesystemURL p0);
    
    abstract long truncateFileAtURL(final LocalFilesystemURL p0, final long p1) throws IOException, NoModificationAllowedException;
    
    abstract long writeToFileAtURL(final LocalFilesystemURL p0, final String p1, final int p2, final boolean p3) throws NoModificationAllowedException, IOException;
    
    protected class LimitedInputStream extends FilterInputStream
    {
        long numBytesToRead;
        
        public LimitedInputStream(final InputStream inputStream, final long numBytesToRead) {
            super(inputStream);
            this.numBytesToRead = numBytesToRead;
        }
        
        @Override
        public int read() throws IOException {
            if (this.numBytesToRead <= 0L) {
                return -1;
            }
            --this.numBytesToRead;
            return this.in.read();
        }
        
        @Override
        public int read(final byte[] array, final int n, final int n2) throws IOException {
            if (this.numBytesToRead <= 0L) {
                return -1;
            }
            int n3 = n2;
            if (n2 > this.numBytesToRead) {
                n3 = (int)this.numBytesToRead;
            }
            final int read = this.in.read(array, n, n3);
            this.numBytesToRead -= read;
            return read;
        }
    }
    
    public interface ReadFileCallback
    {
        void handleData(final InputStream p0, final String p1) throws IOException;
    }
}
