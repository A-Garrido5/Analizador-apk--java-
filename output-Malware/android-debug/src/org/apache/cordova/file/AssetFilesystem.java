// 
// Decompiled by Procyon v0.5.30
// 

package org.apache.cordova.file;

import android.net.Uri$Builder;
import java.io.File;
import org.json.JSONException;
import org.json.JSONObject;
import java.io.IOException;
import java.io.FileNotFoundException;
import android.net.Uri;
import org.apache.cordova.CordovaResourceApi;
import android.content.res.AssetManager;
import java.util.Map;

public class AssetFilesystem extends Filesystem
{
    private static Map<String, Long> lengthCache;
    private static Map<String, String[]> listCache;
    private static boolean listCacheFromFile;
    private static Object listCacheLock;
    private final AssetManager assetManager;
    
    static {
        AssetFilesystem.listCacheLock = new Object();
    }
    
    public AssetFilesystem(final AssetManager assetManager, final CordovaResourceApi cordovaResourceApi) {
        super(Uri.parse("file:///android_asset/"), "assets", cordovaResourceApi);
        this.assetManager = assetManager;
    }
    
    private long getAssetSize(final String s) throws FileNotFoundException {
        String substring = s;
        if (substring.startsWith("/")) {
            substring = substring.substring(1);
        }
        this.lazyInitCaches();
        if (AssetFilesystem.lengthCache != null) {
            final Long n = AssetFilesystem.lengthCache.get(substring);
            if (n == null) {
                throw new FileNotFoundException("Asset not found: " + substring);
            }
            return n;
        }
        else {
            Object openForRead = null;
            try {
                openForRead = this.resourceApi.openForRead(this.nativeUriForFullPath(substring));
                long length = ((CordovaResourceApi.OpenForReadResult)openForRead).length;
                if (length < 0L) {
                    length = ((CordovaResourceApi.OpenForReadResult)openForRead).inputStream.available();
                }
                final long n2 = length;
                if (openForRead == null) {
                    return n2;
                }
                final CordovaResourceApi.OpenForReadResult openForReadResult = (CordovaResourceApi.OpenForReadResult)openForRead;
                try {
                    openForReadResult.inputStream.close();
                    return n2;
                }
                catch (IOException ex) {}
            }
            catch (IOException ex2) {
                throw new FileNotFoundException("File not found: " + substring);
            }
            finally {
                Label_0210: {
                    if (openForRead == null) {
                        break Label_0210;
                    }
                    final CordovaResourceApi.OpenForReadResult openForReadResult2 = (CordovaResourceApi.OpenForReadResult)openForRead;
                    try {
                        openForReadResult2.inputStream.close();
                    }
                    catch (IOException ex3) {}
                }
            }
        }
    }
    
    private boolean isDirectory(final String s) {
        try {
            return this.listAssets(s).length != 0;
        }
        catch (IOException ex) {
            return false;
        }
    }
    
    private void lazyInitCaches() {
        // 
        // This method could not be decompiled.
        // 
        // Original Bytecode:
        // 
        //     0: getstatic       org/apache/cordova/file/AssetFilesystem.listCacheLock:Ljava/lang/Object;
        //     3: astore_1       
        //     4: aload_1        
        //     5: monitorenter   
        //     6: getstatic       org/apache/cordova/file/AssetFilesystem.listCache:Ljava/util/Map;
        //     9: astore_3       
        //    10: aload_3        
        //    11: ifnonnull       107
        //    14: aconst_null    
        //    15: astore          4
        //    17: new             Ljava/io/ObjectInputStream;
        //    20: dup            
        //    21: aload_0        
        //    22: getfield        org/apache/cordova/file/AssetFilesystem.assetManager:Landroid/content/res/AssetManager;
        //    25: ldc             "cdvasset.manifest"
        //    27: invokevirtual   android/content/res/AssetManager.open:(Ljava/lang/String;)Ljava/io/InputStream;
        //    30: invokespecial   java/io/ObjectInputStream.<init>:(Ljava/io/InputStream;)V
        //    33: astore          5
        //    35: aload           5
        //    37: astore          4
        //    39: aload           4
        //    41: invokevirtual   java/io/ObjectInputStream.readObject:()Ljava/lang/Object;
        //    44: checkcast       Ljava/util/Map;
        //    47: putstatic       org/apache/cordova/file/AssetFilesystem.listCache:Ljava/util/Map;
        //    50: aload           4
        //    52: invokevirtual   java/io/ObjectInputStream.readObject:()Ljava/lang/Object;
        //    55: checkcast       Ljava/util/Map;
        //    58: putstatic       org/apache/cordova/file/AssetFilesystem.lengthCache:Ljava/util/Map;
        //    61: iconst_1       
        //    62: putstatic       org/apache/cordova/file/AssetFilesystem.listCacheFromFile:Z
        //    65: aload           4
        //    67: ifnull          79
        //    70: aload           4
        //    72: astore          17
        //    74: aload           17
        //    76: invokevirtual   java/io/ObjectInputStream.close:()V
        //    79: getstatic       org/apache/cordova/file/AssetFilesystem.listCache:Ljava/util/Map;
        //    82: ifnonnull       107
        //    85: ldc             "AssetFilesystem"
        //    87: ldc             "Asset manifest not found. Recursive copies and directory listing will be slow."
        //    89: invokestatic    android/util/Log.w:(Ljava/lang/String;Ljava/lang/String;)I
        //    92: pop            
        //    93: new             Ljava/util/HashMap;
        //    96: dup            
        //    97: invokespecial   java/util/HashMap.<init>:()V
        //   100: astore          13
        //   102: aload           13
        //   104: putstatic       org/apache/cordova/file/AssetFilesystem.listCache:Ljava/util/Map;
        //   107: aload_1        
        //   108: monitorexit    
        //   109: return         
        //   110: astore          18
        //   112: goto            79
        //   115: astore          14
        //   117: aload           14
        //   119: invokevirtual   java/lang/ClassNotFoundException.printStackTrace:()V
        //   122: aload           4
        //   124: ifnull          79
        //   127: aload           4
        //   129: astore          15
        //   131: aload           15
        //   133: invokevirtual   java/io/ObjectInputStream.close:()V
        //   136: goto            79
        //   139: astore          16
        //   141: goto            79
        //   144: astore          9
        //   146: aload           4
        //   148: ifnull          79
        //   151: aload           4
        //   153: astore          10
        //   155: aload           10
        //   157: invokevirtual   java/io/ObjectInputStream.close:()V
        //   160: goto            79
        //   163: astore          11
        //   165: goto            79
        //   168: astore          6
        //   170: aload           4
        //   172: ifnull          184
        //   175: aload           4
        //   177: astore          7
        //   179: aload           7
        //   181: invokevirtual   java/io/ObjectInputStream.close:()V
        //   184: aload           6
        //   186: athrow         
        //   187: astore_2       
        //   188: aload_1        
        //   189: monitorexit    
        //   190: aload_2        
        //   191: athrow         
        //   192: astore          8
        //   194: goto            184
        //    Exceptions:
        //  Try           Handler
        //  Start  End    Start  End    Type                              
        //  -----  -----  -----  -----  ----------------------------------
        //  6      10     187    192    Any
        //  17     35     115    144    Ljava/lang/ClassNotFoundException;
        //  17     35     144    168    Ljava/io/IOException;
        //  17     35     168    187    Any
        //  39     65     115    144    Ljava/lang/ClassNotFoundException;
        //  39     65     144    168    Ljava/io/IOException;
        //  39     65     168    187    Any
        //  74     79     110    115    Ljava/io/IOException;
        //  74     79     187    192    Any
        //  79     107    187    192    Any
        //  107    109    187    192    Any
        //  117    122    168    187    Any
        //  131    136    139    144    Ljava/io/IOException;
        //  131    136    187    192    Any
        //  155    160    163    168    Ljava/io/IOException;
        //  155    160    187    192    Any
        //  179    184    192    197    Ljava/io/IOException;
        //  179    184    187    192    Any
        //  184    187    187    192    Any
        //  188    190    187    192    Any
        // 
        // The error that occurred was:
        // 
        // java.lang.IllegalStateException: Expression is linked from several locations: Label_0184:
        //     at com.strobel.decompiler.ast.Error.expressionLinkedFromMultipleLocations(Error.java:27)
        //     at com.strobel.decompiler.ast.AstOptimizer.mergeDisparateObjectInitializations(AstOptimizer.java:2592)
        //     at com.strobel.decompiler.ast.AstOptimizer.optimize(AstOptimizer.java:235)
        //     at com.strobel.decompiler.ast.AstOptimizer.optimize(AstOptimizer.java:42)
        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:214)
        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:99)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethodBody(AstBuilder.java:757)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethod(AstBuilder.java:655)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addTypeMembers(AstBuilder.java:532)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeCore(AstBuilder.java:499)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeNoCache(AstBuilder.java:141)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createType(AstBuilder.java:130)
        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addType(AstBuilder.java:105)
        //     at com.strobel.decompiler.languages.java.JavaLanguage.buildAst(JavaLanguage.java:71)
        //     at com.strobel.decompiler.languages.java.JavaLanguage.decompileType(JavaLanguage.java:59)
        //     at com.strobel.decompiler.DecompilerDriver.decompileType(DecompilerDriver.java:317)
        //     at com.strobel.decompiler.DecompilerDriver.decompileJar(DecompilerDriver.java:238)
        //     at com.strobel.decompiler.DecompilerDriver.main(DecompilerDriver.java:123)
        // 
        throw new IllegalStateException("An error occurred while decompiling this method.");
    }
    
    private String[] listAssets(final String s) throws IOException {
        String substring = s;
        if (substring.startsWith("/")) {
            substring = substring.substring(1);
        }
        this.lazyInitCaches();
        String[] list = AssetFilesystem.listCache.get(substring);
        if (list == null) {
            if (AssetFilesystem.listCacheFromFile) {
                list = new String[0];
            }
            else {
                list = this.assetManager.list(substring);
                AssetFilesystem.listCache.put(substring, list);
            }
        }
        return list;
    }
    
    @Override
    LocalFilesystemURL URLforFilesystemPath(final String s) {
        return null;
    }
    
    public boolean canRemoveFileAtLocalURL(final LocalFilesystemURL localFilesystemURL) {
        return false;
    }
    
    @Override
    String filesystemPathForURL(final LocalFilesystemURL localFilesystemURL) {
        return null;
    }
    
    public JSONObject getFileForLocalURL(final LocalFilesystemURL localFilesystemURL, final String s, final JSONObject jsonObject, final boolean b) throws FileExistsException, IOException, TypeMismatchException, EncodingException, JSONException {
        String string = s;
        if (jsonObject != null && jsonObject.optBoolean("create")) {
            throw new UnsupportedOperationException("Assets are read-only");
        }
        if (b && !string.endsWith("/")) {
            string += "/";
        }
        LocalFilesystemURL localFilesystemURL2;
        if (string.startsWith("/")) {
            localFilesystemURL2 = this.localUrlforFullPath(Filesystem.normalizePath(string));
        }
        else {
            localFilesystemURL2 = this.localUrlforFullPath(Filesystem.normalizePath(localFilesystemURL.path + "/" + string));
        }
        this.getFileMetadataForLocalURL(localFilesystemURL2);
        final boolean directory = this.isDirectory(localFilesystemURL2.path);
        if (b && !directory) {
            throw new TypeMismatchException("path doesn't exist or is file");
        }
        if (!b && directory) {
            throw new TypeMismatchException("path doesn't exist or is directory");
        }
        return this.makeEntryForURL(localFilesystemURL2);
    }
    
    public JSONObject getFileMetadataForLocalURL(final LocalFilesystemURL localFilesystemURL) throws FileNotFoundException {
        final JSONObject jsonObject = new JSONObject();
        Label_0098: {
            if (!localFilesystemURL.isDirectory) {
                break Label_0098;
            }
            long assetSize = 0L;
            while (true) {
                final long n = assetSize;
                try {
                    jsonObject.put("size", n);
                    String mimeType;
                    if (localFilesystemURL.isDirectory) {
                        mimeType = "text/directory";
                    }
                    else {
                        mimeType = this.resourceApi.getMimeType(this.toNativeUri(localFilesystemURL));
                    }
                    jsonObject.put("type", (Object)mimeType);
                    jsonObject.put("name", (Object)new File(localFilesystemURL.path).getName());
                    jsonObject.put("fullPath", (Object)localFilesystemURL.path);
                    jsonObject.put("lastModifiedDate", 0);
                    return jsonObject;
                    assetSize = this.getAssetSize(localFilesystemURL.path);
                }
                catch (JSONException ex) {
                    return null;
                }
            }
        }
    }
    
    public LocalFilesystemURL[] listChildren(final LocalFilesystemURL localFilesystemURL) throws FileNotFoundException {
        String s = localFilesystemURL.path.substring(1);
        if (s.endsWith("/")) {
            s = s.substring(0, -1 + s.length());
        }
        final String s2 = s;
        LocalFilesystemURL[] array;
        try {
            final String[] listAssets = this.listAssets(s2);
            array = new LocalFilesystemURL[listAssets.length];
            for (int i = 0; i < listAssets.length; ++i) {
                array[i] = this.localUrlforFullPath(new File(localFilesystemURL.path, listAssets[i]).getPath());
            }
        }
        catch (IOException ex) {
            throw new FileNotFoundException();
        }
        return array;
    }
    
    @Override
    boolean recursiveRemoveFileAtLocalURL(final LocalFilesystemURL localFilesystemURL) throws NoModificationAllowedException {
        throw new NoModificationAllowedException("Assets are read-only");
    }
    
    @Override
    boolean removeFileAtLocalURL(final LocalFilesystemURL localFilesystemURL) throws InvalidModificationException, NoModificationAllowedException {
        throw new NoModificationAllowedException("Assets are read-only");
    }
    
    @Override
    public LocalFilesystemURL toLocalUri(final Uri uri) {
        if (!"file".equals(uri.getScheme())) {
            return null;
        }
        final Uri fromFile = Uri.fromFile(new File(uri.getPath()));
        final String encodedPath = this.rootUri.getEncodedPath();
        final String substring = encodedPath.substring(0, -1 + encodedPath.length());
        if (!fromFile.getEncodedPath().startsWith(substring)) {
            return null;
        }
        String s = fromFile.getEncodedPath().substring(substring.length());
        if (!s.isEmpty()) {
            s = s.substring(1);
        }
        final Uri$Builder path = new Uri$Builder().scheme("cdvfile").authority("localhost").path(this.name);
        if (!s.isEmpty()) {
            path.appendEncodedPath(s);
        }
        if (this.isDirectory(s) || uri.getPath().endsWith("/")) {
            path.appendEncodedPath("");
        }
        return LocalFilesystemURL.parse(path.build());
    }
    
    @Override
    public Uri toNativeUri(final LocalFilesystemURL localFilesystemURL) {
        return this.nativeUriForFullPath(localFilesystemURL.path);
    }
    
    @Override
    long truncateFileAtURL(final LocalFilesystemURL localFilesystemURL, final long n) throws IOException, NoModificationAllowedException {
        throw new NoModificationAllowedException("Assets are read-only");
    }
    
    @Override
    long writeToFileAtURL(final LocalFilesystemURL localFilesystemURL, final String s, final int n, final boolean b) throws NoModificationAllowedException, IOException {
        throw new NoModificationAllowedException("Assets are read-only");
    }
}
