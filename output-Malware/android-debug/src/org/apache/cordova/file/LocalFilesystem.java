// 
// Decompiled by Procyon v0.5.30
// 

package org.apache.cordova.file;

import java.io.ByteArrayInputStream;
import android.util.Base64;
import java.io.RandomAccessFile;
import android.net.Uri$Builder;
import org.json.JSONException;
import java.io.FileNotFoundException;
import org.json.JSONObject;
import android.os.Environment;
import android.os.Build$VERSION;
import java.nio.channels.FileChannel;
import java.io.InputStream;
import java.nio.channels.ReadableByteChannel;
import java.io.FileInputStream;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import android.content.Intent;
import android.net.Uri;
import java.io.File;
import org.apache.cordova.CordovaResourceApi;
import android.content.Context;

public class LocalFilesystem extends Filesystem
{
    private final Context context;
    
    public LocalFilesystem(final String s, final Context context, final CordovaResourceApi cordovaResourceApi, final File file) {
        super(Uri.fromFile(file).buildUpon().appendEncodedPath("").build(), s, cordovaResourceApi);
        this.context = context;
    }
    
    private void broadcastNewFile(final Uri uri) {
        this.context.sendBroadcast(new Intent("android.intent.action.MEDIA_SCANNER_SCAN_FILE", uri));
    }
    
    private void copyDirectory(final Filesystem filesystem, final LocalFilesystemURL localFilesystemURL, final File file, final boolean b) throws IOException, NoModificationAllowedException, InvalidModificationException, FileExistsException {
        if (b) {
            final String filesystemPathForURL = filesystem.filesystemPathForURL(localFilesystemURL);
            if (filesystemPathForURL != null) {
                final File file2 = new File(filesystemPathForURL);
                if (file.exists()) {
                    if (file.list().length > 0) {
                        throw new InvalidModificationException("directory is not empty");
                    }
                    file.delete();
                }
                if (file2.renameTo(file)) {
                    return;
                }
            }
        }
        if (file.exists()) {
            if (file.list().length > 0) {
                throw new InvalidModificationException("directory is not empty");
            }
        }
        else if (!file.mkdir()) {
            throw new NoModificationAllowedException("Couldn't create the destination directory");
        }
        for (final LocalFilesystemURL localFilesystemURL2 : filesystem.listChildren(localFilesystemURL)) {
            final File file3 = new File(file, new File(localFilesystemURL2.path).getName());
            if (localFilesystemURL2.isDirectory) {
                this.copyDirectory(filesystem, localFilesystemURL2, file3, false);
            }
            else {
                this.copyFile(filesystem, localFilesystemURL2, file3, false);
            }
        }
        if (b) {
            filesystem.recursiveRemoveFileAtLocalURL(localFilesystemURL);
        }
    }
    
    private void copyFile(final Filesystem filesystem, final LocalFilesystemURL localFilesystemURL, final File file, final boolean b) throws IOException, InvalidModificationException, NoModificationAllowedException {
        if (b) {
            final String filesystemPathForURL = filesystem.filesystemPathForURL(localFilesystemURL);
            if (filesystemPathForURL != null && new File(filesystemPathForURL).renameTo(file)) {
                return;
            }
        }
        copyResource(this.resourceApi.openForRead(filesystem.toNativeUri(localFilesystemURL)), new FileOutputStream(file));
        if (b) {
            filesystem.removeFileAtLocalURL(localFilesystemURL);
        }
    }
    
    private static void copyResource(final CordovaResourceApi.OpenForReadResult openForReadResult, final OutputStream outputStream) throws IOException {
        try {
            final InputStream inputStream = openForReadResult.inputStream;
            if (inputStream instanceof FileInputStream && outputStream instanceof FileOutputStream) {
                final FileChannel channel = ((FileInputStream)openForReadResult.inputStream).getChannel();
                final FileChannel channel2 = ((FileOutputStream)outputStream).getChannel();
                long startOffset = 0L;
                final long length = openForReadResult.length;
                if (openForReadResult.assetFd != null) {
                    startOffset = openForReadResult.assetFd.getStartOffset();
                }
                channel.position(startOffset);
                channel2.transferFrom(channel, 0L, length);
            }
            else {
                final byte[] array = new byte[8192];
                while (true) {
                    final int read = inputStream.read(array, 0, 8192);
                    if (read <= 0) {
                        break;
                    }
                    outputStream.write(array, 0, read);
                }
            }
        }
        finally {
            openForReadResult.inputStream.close();
            if (outputStream != null) {
                outputStream.close();
            }
        }
    }
    
    private String fullPathForFilesystemPath(final String s) {
        if (s != null && s.startsWith(this.rootUri.getPath())) {
            return s.substring(-1 + this.rootUri.getPath().length());
        }
        return null;
    }
    
    private boolean isPublicDirectory(final String s) {
        if (Build$VERSION.SDK_INT >= 21) {
            for (final File file : this.context.getExternalMediaDirs()) {
                if (file != null && s.startsWith(file.getAbsolutePath())) {
                    return true;
                }
            }
        }
        return s.startsWith(Environment.getExternalStorageDirectory().getAbsolutePath());
    }
    
    public LocalFilesystemURL URLforFilesystemPath(final String s) {
        return this.localUrlforFullPath(this.fullPathForFilesystemPath(s));
    }
    
    public boolean canRemoveFileAtLocalURL(final LocalFilesystemURL localFilesystemURL) {
        return new File(this.filesystemPathForURL(localFilesystemURL)).exists();
    }
    
    @Override
    public JSONObject copyFileToURL(final LocalFilesystemURL localFilesystemURL, final String s, final Filesystem filesystem, final LocalFilesystemURL localFilesystemURL2, final boolean b) throws IOException, InvalidModificationException, JSONException, NoModificationAllowedException, FileExistsException {
        if (!new File(this.filesystemPathForURL(localFilesystemURL)).exists()) {
            throw new FileNotFoundException("The source does not exist");
        }
        final LocalFilesystemURL destinationURL = this.makeDestinationURL(s, localFilesystemURL2, localFilesystemURL, localFilesystemURL2.isDirectory);
        final Uri nativeUri = this.toNativeUri(destinationURL);
        final Uri nativeUri2 = filesystem.toNativeUri(localFilesystemURL2);
        if (nativeUri.equals((Object)nativeUri2)) {
            throw new InvalidModificationException("Can't copy onto itself");
        }
        if (b && !filesystem.canRemoveFileAtLocalURL(localFilesystemURL2)) {
            throw new InvalidModificationException("Source URL is read-only (cannot move)");
        }
        final File file = new File(nativeUri.getPath());
        if (file.exists()) {
            if (!localFilesystemURL2.isDirectory && file.isDirectory()) {
                throw new InvalidModificationException("Can't copy/move a file to an existing directory");
            }
            if (localFilesystemURL2.isDirectory && file.isFile()) {
                throw new InvalidModificationException("Can't copy/move a directory to an existing file");
            }
        }
        if (localFilesystemURL2.isDirectory) {
            if (nativeUri.toString().startsWith(nativeUri2.toString() + '/')) {
                throw new InvalidModificationException("Can't copy directory into itself");
            }
            this.copyDirectory(filesystem, localFilesystemURL2, file, b);
        }
        else {
            this.copyFile(filesystem, localFilesystemURL2, file, b);
        }
        return this.makeEntryForURL(destinationURL);
    }
    
    @Override
    public boolean exists(final LocalFilesystemURL localFilesystemURL) {
        return new File(this.filesystemPathForURL(localFilesystemURL)).exists();
    }
    
    public String filesystemPathForFullPath(final String s) {
        return new File(this.rootUri.getPath(), s).toString();
    }
    
    public String filesystemPathForURL(final LocalFilesystemURL localFilesystemURL) {
        return this.filesystemPathForFullPath(localFilesystemURL.path);
    }
    
    public JSONObject getFileForLocalURL(final LocalFilesystemURL localFilesystemURL, final String s, final JSONObject jsonObject, final boolean b) throws FileExistsException, IOException, TypeMismatchException, EncodingException, JSONException {
        String string = s;
        boolean b2 = false;
        boolean optBoolean = false;
        if (jsonObject != null) {
            final boolean optBoolean2;
            b2 = (optBoolean2 = jsonObject.optBoolean("create"));
            optBoolean = false;
            if (optBoolean2) {
                optBoolean = jsonObject.optBoolean("exclusive");
            }
        }
        if (string.contains(":")) {
            throw new EncodingException("This path has an invalid \":\" in it.");
        }
        if (b && !string.endsWith("/")) {
            string += "/";
        }
        LocalFilesystemURL localFilesystemURL2;
        if (string.startsWith("/")) {
            localFilesystemURL2 = this.localUrlforFullPath(Filesystem.normalizePath(string));
        }
        else {
            localFilesystemURL2 = this.localUrlforFullPath(Filesystem.normalizePath(localFilesystemURL.path + "/" + string));
        }
        final File file = new File(this.filesystemPathForURL(localFilesystemURL2));
        if (b2) {
            if (optBoolean && file.exists()) {
                throw new FileExistsException("create/exclusive fails");
            }
            if (b) {
                file.mkdir();
            }
            else {
                file.createNewFile();
            }
            if (!file.exists()) {
                throw new FileExistsException("create fails");
            }
        }
        else {
            if (!file.exists()) {
                throw new FileNotFoundException("path does not exist");
            }
            if (b) {
                if (file.isFile()) {
                    throw new TypeMismatchException("path doesn't exist or is file");
                }
            }
            else if (file.isDirectory()) {
                throw new TypeMismatchException("path doesn't exist or is directory");
            }
        }
        return this.makeEntryForURL(localFilesystemURL2);
    }
    
    public JSONObject getFileMetadataForLocalURL(final LocalFilesystemURL localFilesystemURL) throws FileNotFoundException {
        final File file = new File(this.filesystemPathForURL(localFilesystemURL));
        if (!file.exists()) {
            throw new FileNotFoundException("File at " + localFilesystemURL.uri + " does not exist.");
        }
        final JSONObject jsonObject = new JSONObject();
        try {
            long length;
            if (file.isDirectory()) {
                length = 0L;
            }
            else {
                length = file.length();
            }
            jsonObject.put("size", length);
            jsonObject.put("type", (Object)this.resourceApi.getMimeType(Uri.fromFile(file)));
            jsonObject.put("name", (Object)file.getName());
            jsonObject.put("fullPath", (Object)localFilesystemURL.path);
            jsonObject.put("lastModifiedDate", file.lastModified());
            return jsonObject;
        }
        catch (JSONException ex) {
            return null;
        }
    }
    
    public LocalFilesystemURL[] listChildren(final LocalFilesystemURL localFilesystemURL) throws FileNotFoundException {
        final File file = new File(this.filesystemPathForURL(localFilesystemURL));
        if (!file.exists()) {
            throw new FileNotFoundException();
        }
        final File[] listFiles = file.listFiles();
        if (listFiles == null) {
            return null;
        }
        final LocalFilesystemURL[] array = new LocalFilesystemURL[listFiles.length];
        for (int i = 0; i < listFiles.length; ++i) {
            array[i] = this.URLforFilesystemPath(listFiles[i].getPath());
        }
        return array;
    }
    
    public boolean recursiveRemoveFileAtLocalURL(final LocalFilesystemURL localFilesystemURL) throws FileExistsException {
        return this.removeDirRecursively(new File(this.filesystemPathForURL(localFilesystemURL)));
    }
    
    protected boolean removeDirRecursively(final File file) throws FileExistsException {
        if (file.isDirectory()) {
            final File[] listFiles = file.listFiles();
            for (int length = listFiles.length, i = 0; i < length; ++i) {
                this.removeDirRecursively(listFiles[i]);
            }
        }
        if (!file.delete()) {
            throw new FileExistsException("could not delete: " + file.getName());
        }
        return true;
    }
    
    public boolean removeFileAtLocalURL(final LocalFilesystemURL localFilesystemURL) throws InvalidModificationException {
        final File file = new File(this.filesystemPathForURL(localFilesystemURL));
        if (file.isDirectory() && file.list().length > 0) {
            throw new InvalidModificationException("You can't delete a directory that is not empty.");
        }
        return file.delete();
    }
    
    @Override
    public LocalFilesystemURL toLocalUri(final Uri uri) {
        if (!"file".equals(uri.getScheme())) {
            return null;
        }
        final File file = new File(uri.getPath());
        final Uri fromFile = Uri.fromFile(file);
        final String encodedPath = this.rootUri.getEncodedPath();
        final String substring = encodedPath.substring(0, -1 + encodedPath.length());
        if (!fromFile.getEncodedPath().startsWith(substring)) {
            return null;
        }
        String s = fromFile.getEncodedPath().substring(substring.length());
        if (!s.isEmpty()) {
            s = s.substring(1);
        }
        final Uri$Builder path = new Uri$Builder().scheme("cdvfile").authority("localhost").path(this.name);
        if (!s.isEmpty()) {
            path.appendEncodedPath(s);
        }
        if (file.isDirectory() || uri.getPath().endsWith("/")) {
            path.appendEncodedPath("");
        }
        return LocalFilesystemURL.parse(path.build());
    }
    
    @Override
    public Uri toNativeUri(final LocalFilesystemURL localFilesystemURL) {
        return this.nativeUriForFullPath(localFilesystemURL.path);
    }
    
    public long truncateFileAtURL(final LocalFilesystemURL localFilesystemURL, final long n) throws IOException {
        if (!new File(this.filesystemPathForURL(localFilesystemURL)).exists()) {
            throw new FileNotFoundException("File at " + localFilesystemURL.uri + " does not exist.");
        }
        final RandomAccessFile randomAccessFile = new RandomAccessFile(this.filesystemPathForURL(localFilesystemURL), "rw");
        try {
            if (randomAccessFile.length() >= n) {
                randomAccessFile.getChannel().truncate(n);
                return n;
            }
            return randomAccessFile.length();
        }
        finally {
            randomAccessFile.close();
        }
    }
    
    public long writeToFileAtURL(final LocalFilesystemURL localFilesystemURL, final String s, final int n, final boolean b) throws IOException, NoModificationAllowedException {
        boolean b2 = false;
        if (n > 0) {
            this.truncateFileAtURL(localFilesystemURL, n);
            b2 = true;
        }
        Label_0139: {
            if (!b) {
                break Label_0139;
            }
            byte[] array = Base64.decode(s, 0);
            while (true) {
                final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(array);
                final byte[] array2 = array;
                try {
                    final byte[] array3 = new byte[array2.length];
                    final String filesystemPathForURL = this.filesystemPathForURL(localFilesystemURL);
                    final FileOutputStream fileOutputStream = new FileOutputStream(filesystemPathForURL, b2);
                    try {
                        byteArrayInputStream.read(array3, 0, array3.length);
                        fileOutputStream.write(array3, 0, array.length);
                        fileOutputStream.flush();
                        fileOutputStream.close();
                        if (this.isPublicDirectory(filesystemPathForURL)) {
                            this.broadcastNewFile(Uri.fromFile(new File(filesystemPathForURL)));
                        }
                        return array.length;
                        array = s.getBytes();
                    }
                    finally {
                        fileOutputStream.close();
                    }
                }
                catch (NullPointerException ex) {
                    throw new NoModificationAllowedException(localFilesystemURL.toString());
                }
            }
        }
    }
}
